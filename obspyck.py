#!/usr/bin/env python
# -*- coding: utf-8 -*-
#-------------------------------------------------------------------
# Filename: obspyck.py
#  Purpose: ObsPyck main program
#   Author: Tobias Megies, Lion Krischer
#    Email: megies@geophysik.uni-muenchen.de
#  License: GPLv2
#
# Copyright (C) 2010 Tobias Megies, Lion Krischer
#---------------------------------------------------------------------

import os
import sys
import shutil
import optparse
import warnings
import tempfile
import socket
from StringIO import StringIO

from PyQt4 import QtGui, QtCore
from PyQt4.QtCore import QEvent, Qt
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm
import matplotlib.transforms
from matplotlib.patches import Ellipse
from matplotlib.ticker import FuncFormatter, FormatStrFormatter, MaxNLocator
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as QNavigationToolbar
from matplotlib.backend_bases import MouseEvent as MplMouseEvent, KeyEvent as MplKeyEvent
import lxml.etree
from lxml.etree import SubElement as Sub

#sys.path.append('/baysoft/obspy/misc/symlink')
#os.chdir("/baysoft/obspyck/")
from obspy.core.util import NamedTemporaryFile, AttribDict
from obspy.core.util.geodetics import gps2DistAzimuth
from obspy import UTCDateTime, Stream#, readEvents
from obspy.signal.util import utlLonLat, utlGeoKm
from obspy.signal.invsim import estimateMagnitude, paz2AmpValueOfFreqResp
from obspy.signal import rotate_ZNE_LQT, rotate_NE_RT
from obspy.signal import arPick
from obspy.signal.util import az2baz2az
from obspy.imaging.spectrogram import spectrogram
from obspy.imaging.beachball import Beachball

from qt_designer import Ui_qMainWindow_obsPyck
from util import *
from event_helper import Catalog, Event, Origin, Pick, Arrival, \
    Magnitude, StationMagnitude, StationMagnitudeContribution, \
    FocalMechanism, ResourceIdentifier, ID_ROOT, readEvents, Amplitude
from obspy.core.event import CreationInfo, WaveformStreamID, \
    OriginUncertainty, OriginQuality

NAMESPACE = ("edb", "http://erdbeben-in-bayern.de/xmlns/0.1")


class ObsPyck(QtGui.QMainWindow):
    """
    Main Window with the design loaded from the Qt Designer.
    """
    def __init__(self, clients, streams, options, keys):
        """
        Standard init.
        """
        self.clients = clients
        self.streams = streams
        self.options = options
        self.keys = keys

        # T0 is the global reference time (zero in relative time scales)
        self.T0 = UTCDateTime(options.time)
        self.T0 += options.starttime_offset
        # T1 is the end time specified by user
        self.T1 = self.T0 + options.duration
        
        # init the GUI stuff
        QtGui.QMainWindow.__init__(self)
        # Init the widgets from the autogenerated file.
        # All GUI elements will be accessible via self.widgets.name_of_element
        self.widgets = Ui_qMainWindow_obsPyck()
        self.widgets.setupUi(self)

        # Create little color icons in front of the phase type combo box.
        # Needs to be done pretty much at the beginning because some other
        # stuff relies on the phase type being set.
        pixmap = QtGui.QPixmap(70, 50)
        for phase_type in list(SEISMIC_PHASES) + ['Mag']:
            rgb = matplotlib_color_to_rgb(PHASE_COLORS[phase_type])
            pixmap.fill(QtGui.QColor(*rgb))
            icon = QtGui.QIcon(pixmap)
            self.widgets.qComboBox_phaseType.addItem(icon, phase_type)

        self.qMain = self.widgets.centralwidget
        # Add write methods to stdout/stderr text edits in GUI displays to
        # enable redirections for stdout and stderr.
        # we need to remember the original handles because we only write on the
        # console during debug modus.
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        # We automatically redirect all messages to both console and Gui boxes
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)
        # Matplotlib figure.
        # we bind the figure to the FigureCanvas, so that it will be
        # drawn using the specific backend graphic functions
        self.canv = self.widgets.qMplCanvas
        # We have to reset all splitters such that the widget with the canvas
        # in it can not be collapsed as this leads to a crash of the program
        _i = self.widgets.qSplitter_vertical.indexOf(self.widgets.qSplitter_horizontal)
        self.widgets.qSplitter_vertical.setCollapsible(_i, False)
        _i = self.widgets.qSplitter_horizontal.indexOf(self.widgets.qWidget_mpl)
        self.widgets.qSplitter_horizontal.setCollapsible(_i, False)
        # XXX this resizing operation (buttons minimum size) should be done in
        # XXX the qt_designer.ui but I didn't find the correct settings there..
        self.widgets.qSplitter_horizontal.setSizes([1, 9999])
        # Bind the canvas to the mouse wheel event. Use Qt events for it
        # because the matplotlib events seem to have a problem with Debian.
        self.widgets.qMplCanvas.wheelEvent = self.__mpl_wheelEvent
        #self.keyPressEvent = self.__mpl_keyPressEvent

        # some SeisHub specific adjustments
        if 'SeisHub' in clients:
            from obspy.seishub import Client
            self.SClient = Client
        else:
            msg = "Warning: SeisHub specific features will not work " + \
                  "(e.g. 'send Event')."
            print >> sys.stderr, msg

        self.fig = self.widgets.qMplCanvas.fig
        facecolor = self.qMain.palette().color(QtGui.QPalette.Window).getRgb()
        self.fig.set_facecolor([value / 255.0 for value in facecolor])

        #Define some flags, dictionaries and plotting options
        #this next flag indicates if we zoom on time or amplitude axis
        self.flagWheelZoomAmplitude = False
        check_keybinding_conflicts(KEYS)
        try:
            self.tmp_dir = setup_external_programs(options)
        except IOError:
            msg = "Cannot find external programs dir, localization " + \
                  "methods/functions are deactivated"
            warnings.warn(msg)
        self.picks = []
        self.amplitudes = []
        self.origin = Origin()
        self.magnitude = Magnitude()
        self.focalMechanism = FocalMechanism() # currently selected focal mechanism
        self.focMechList = [] # list for all focal mechanisms from focmec
        # indicates which of the available focal mechanisms is selected
        self.focMechCurrent = None 
        # indicates how many focal mechanisms are available from focmec
        self.focMechCount = None
        self.event = Event()
        self.spectrogramColormap = matplotlib.cm.jet
        # indicates which of the available events from seishub was loaded
        self.seishubEventCurrent = None 
        # indicates how many events are available from seishub
        self.seishubEventCount = None
        # save username of current user
        try:
            self.username = os.getlogin()
        except:
            try:
                self.username = os.environ['USER']
            except:
                self.username = "unknown"
        # setup server information
        self.server = {}
        server = self.server
        server['Server'] = "%s:%i" % (options.seishub_servername,
                                      options.seishub_port)
        server['BaseUrl'] = "http://" + server['Server']
        server['User'] = options.seishub_user # "obspyck"
        
        (warn_msg, merge_msg, streams) = \
                merge_check_and_cleanup_streams(streams, options)
        # if it's not empty show the merge info message now
        if merge_msg:
            print merge_msg
        # exit if no streams are left after removing everything not suited.
        if not streams:
            err = "No streams left to work with after removing bad streams."
            raise Exception(err)

        # set up dictionaries to store phase_type/axes/line informations
        self.lines = {}
        self.texts = {}

        # sort streams by station name
        streams.sort(key=lambda st: st[0].stats['station'])
        (streams, dicts) = setup_dicts(streams, options)
        self.dicts = dicts
        self.eventMapColors = []
        for i in xrange(len(dicts)):
            self.eventMapColors.append((0.,  1.,  0.,  1.))

        #Define a pointer to navigate through the streams
        self.stNum = len(streams)
        self.stPt = 0
        
        self.drawAxes()
        self.multicursor = MultiCursor(self.canv, self.axs, useblit=True,
                                       color='k', linewidth=1, ls='dotted')

        # Initialize the stream related widgets with the right values:
        self.widgets.qComboBox_streamName.clear()
        labels = ["%s.%s" % (st[0].stats.network, st[0].stats.station) \
                  for st in self.streams]
        self.widgets.qComboBox_streamName.addItems(labels)

        # set the filter/trigger default values according to command line
        # options or optionparser default values
        self.widgets.qDoubleSpinBox_highpass.setValue(self.options.highpass)
        self.widgets.qDoubleSpinBox_lowpass.setValue(self.options.lowpass)
        self.widgets.qDoubleSpinBox_sta.setValue(self.options.sta)
        self.widgets.qDoubleSpinBox_lta.setValue(self.options.lta)
        self.widgets.qToolButton_filter.setChecked(self.options.filter)
        self.updateStreamLabels()

        print >> sys.stderr, warn_msg

        # XXX mpl connect XXX XXX XXX XXX XXX
        # XXX http://eli.thegreenplace.net/files/prog_code/qt_mpl_bars.py.txt
        # XXX http://eli.thegreenplace.net/2009/01/20/matplotlib-with-pyqt-guis/
        # XXX https://www.packtpub.com/sites/default/files/sample_chapters/7900-matplotlib-for-python-developers-sample-chapter-6-embedding-matplotlib-in-qt-4.pdf
        # XXX mpl connect XXX XXX XXX XXX XXX
        # Activate all mouse/key/Cursor-events
        # XXX MAYBE rename the event handles again so that they DONT get
        # XXX autoconnected via Qt?!?!?
        self.canv.mpl_connect('key_press_event', self.__mpl_keyPressEvent)
        self.canv.mpl_connect('key_release_event', self.__mpl_keyReleaseEvent)
        self.canv.mpl_connect('button_release_event', self.__mpl_mouseButtonReleaseEvent)
        # The scroll event is handled using Qt.
        #self.canv.mpl_connect('scroll_event', self.__mpl_wheelEvent)
        self.canv.mpl_connect('button_press_event', self.__mpl_mouseButtonPressEvent)
        self.canv.mpl_connect('motion_notify_event', self.__mpl_motionNotifyEvent)
        self.multicursorReinit()
        self.canv.show()
        self.showMaximized()
        # XXX XXX the good old focus issue again!?! no events get to the mpl canvas
        # XXX self.canv.setFocusPolicy(Qt.WheelFocus)
        #print self.canv.hasFocus()
        if 'SeisHub' in self.clients:
            self.updateEventListFromSeisHub(self.T0, self.T1)

    def getCurrentStream(self):
        """
        returns currently active/displayed stream
        """
        return self.streams[self.stPt]

    def getCurrentDict(self):
        """
        returns dictionary for currently active/displayed stream
        """
        return self.dicts[self.stPt]

    #def getCurrentPicks(self):
    #    """
    #    returns dictionary with picks for currently active/displayed stream
    #    (empty dictionary else)
    #    """
    #    return self.dicts[self.stPt].get("picks", {})

    def getCurrentPhase(self):
        """
        returns currently active phase as a string
        """
        return str(self.widgets.qComboBox_phaseType.currentText())

    def time_abs2rel(self, abstime):
        """
        Converts an absolute UTCDateTime to the time in ObsPyck's relative time
        frame.

        :type abstime: :class:`obspy.core.utcdatetime.UTCDateTime`
        :param abstime: Absolute time in UTC.
        :returns: time in ObsPyck's relative time as a float
        """
        return abstime - self.T0

    def time_rel2abs(self, reltime):
        """
        Converts a relative time in global relative time system to the absolute
        UTCDateTime.

        :type reltime: float
        :param reltime: Relative time in ObsPyck's realtive time frame
        :returns: absolute UTCDateTime
        """
        return self.T0 + reltime
    
    def cleanup(self):
        """
        Cleanup and prepare for quit.
        Do:
            - check if sysop duplicates are there
            - remove temporary directory and all contents
        """
        if 'SeisHub' in self.clients:
            self.checkForSysopEventDuplicates(self.T0, self.T1)
        try:
            shutil.rmtree(self.tmp_dir)
        except:
            pass

    ###########################################################################
    ### signal handlers START #################################################
    ###########################################################################

    def on_qToolButton_overview_toggled(self):
        state = self.widgets.qToolButton_overview.isChecked()
        widgets_leave_active = ("qToolButton_overview",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawStreamOverview()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delAxes()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_clearAll_clicked(self, *args):
        # Workaround for overloaded signals:
        #  - "clicked" signal get emitted once without *args and once with an
        #    int as additional argument
        #  - we have to be flexible in the call, otherwise we get errors
        #  - we have to catch one signal, otherwise the action gets performed
        #    twice
        if args:
            return
        self.clearDictionaries()
        self.updateAllItems()
        self.redraw()

    def on_qToolButton_clearOrigMag_clicked(self, *args):
        if args:
            return
        self.clearOriginMagnitudeDictionaries()
        self.updateAllItems()
        self.redraw()

    def on_qToolButton_clearFocMec_clicked(self, *args):
        if args:
            return
        self.clearFocmecDictionary()

    def on_qToolButton_doHyp2000_clicked(self, *args):
        if args:
            return
        #self.delAllItems()
        self.clearOriginMagnitudeDictionaries()
        self.doHyp2000()
        self.loadHyp2000Data()
        self.calculateEpiHypoDists()
        self.calculateStationMagnitudes()
        self.updateNetworkMag()
        self.drawAllItems()
        self.redraw()
        self.widgets.qToolButton_showMap.setChecked(True)

    def on_qToolButton_do3dloc_clicked(self, *args):
        msg = "Not updated after massive QuakeML restructuring."
        raise NotImplementedError(msg)

    def on_qToolButton_doNlloc_clicked(self, *args):
        if args:
            return
        #self.delAllItems()
        self.clearOriginMagnitudeDictionaries()
        self.doNLLoc()
        self.loadNLLocOutput()
        self.calculateEpiHypoDists()
        self.calculateStationMagnitudes()
        self.updateNetworkMag()
        self.drawAllItems()
        self.redraw()
        self.widgets.qToolButton_showMap.setChecked(True)

    def on_qToolButton_calcMag_clicked(self, *args):
        if args:
            return
        self.calculateEpiHypoDists()
        self.calculateStationMagnitudes()
        self.updateNetworkMag()

    def on_qToolButton_doFocMec_clicked(self, *args):
        if args:
            return
        self.clearFocmecDictionary()
        self.doFocmec()

    def on_qToolButton_showMap_toggled(self):
        state = self.widgets.qToolButton_showMap.isChecked()
        widgets_leave_active = ("qToolButton_showMap",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        # XXX XXX would be better to avoid list of widget names nd do it
        # XXX XXX dynamically, but it doesnt work..
        # XXX tmp = (getattr(self.widgets, name) for name in widgets_leave_active)
        # XXX for widget in self.children():
        # XXX     print "%s\n" % widget.objectName()
        # XXX     widget.setEnabled(not state)
        # XXX for widget in tmp:
        # XXX     widget.setEnabled(state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawEventMap()
            self.multicursor.visible = False
            self.canv.draw()
            #print "http://maps.google.de/maps?f=q&q=%.6f,%.6f" % \
            #       (self.dictOrigin['Latitude'], self.dictOrigin['Longitude'])
            link = "http://maps.google.de/maps?f=q&q=%.6f,%.6f" % \
                    (self.origin.latitude, self.origin.longitude)
            self.widgets.qPlainTextEdit_stdout.appendHtml("<a href='%s'>%s</a> &nbsp;" % (link, link))
        else:
            self.delEventMap()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_showFocMec_toggled(self):
        state = self.widgets.qToolButton_showFocMec.isChecked()
        widgets_leave_active = ("qToolButton_showFocMec",
                                "qToolButton_nextFocMec",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawFocMec()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delFocMec()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_nextFocMec_clicked(self, *args):
        if args:
            return
        self.nextFocMec()
        if self.widgets.qToolButton_showFocMec.isChecked():
            self.delFocMec()
            self.fig.clear()
            self.drawFocMec()
            self.canv.draw()

    def on_qToolButton_showWadati_toggled(self):
        state = self.widgets.qToolButton_showWadati.isChecked()
        widgets_leave_active = ("qToolButton_showWadati",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawWadati()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delWadati()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_getNextEvent_clicked(self, *args):
        if args:
            return
        # check if event list is empty and force an update if this is the case
        if not hasattr(self, "seishubEventList"):
            self.updateEventListFromSeisHub(self.T0, self.T1)
        if not self.seishubEventList:
            print "No events available from SeisHub."
            return
        # iterate event number to fetch
        self.seishubEventCurrent = (self.seishubEventCurrent + 1) % \
                                   self.seishubEventCount
        event = self.seishubEventList[self.seishubEventCurrent]
        resource_name = str(event.get('resource_name'))
        self.clearDictionaries()
        self.getEventFromSeisHub(resource_name)
        self.updateAllItems()
        self.redraw()
        
    def on_qToolButton_updateEventList_clicked(self, *args):
        if args:
            return
        self.updateEventListFromSeisHub(self.T0, self.T1)

    def on_qToolButton_sendNewEvent_clicked(self, *args):
        if args:
            return
        # if sysop event and information missing show error and abort upload
        if self.widgets.qCheckBox_sysop.isChecked():
            if not self.checkForCompleteEvent():
                self.popupBadEventError()
                return
        self.setXMLEventID()
        self.uploadSeisHub()
        self.on_qToolButton_updateEventList_clicked()
        self.checkForSysopEventDuplicates(self.T0, self.T1)

    def on_qCheckBox_publishEvent_toggled(self):
        newstate = self.widgets.qCheckBox_publishEvent.isChecked()
        print "Setting \"public\" flag of event to: %s" % newstate

    def on_qToolButton_replaceEvent_clicked(self, *args):
        if args:
            return
        # if sysop event and information missing show error and abort upload
        if self.widgets.qCheckBox_sysop.isChecked():
            if not self.checkForCompleteEvent():
                self.popupBadEventError()
                return
        event = self.seishubEventList[self.seishubEventCurrent]
        resource_name = event.get('resource_name')
        if not resource_name.startswith("obspyck_"):
            err = "Error: Only replacing of events created with ObsPyck allowed."
            print >> sys.stderr, err
            return
        event_id = resource_name.split("_")[1]
        try:
            user = ev.creation_info.author
        except:
            user = None
        qMessageBox = QtGui.QMessageBox()
        qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
        qMessageBox.setIcon(QtGui.QMessageBox.Warning)
        qMessageBox.setWindowTitle("Replace?")
        qMessageBox.setText("Overwrite event in database?")
        msg = "%s  (user: %s)" % (resource_name, user)
        msg += "\n\nWarning: Loading and then sending events might result " + \
               "in loss of information in the xml file (e.g. all custom " + \
               "defined fields!)"
        qMessageBox.setInformativeText(msg)
        qMessageBox.setStandardButtons(QtGui.QMessageBox.Cancel | QtGui.QMessageBox.Ok)
        qMessageBox.setDefaultButton(QtGui.QMessageBox.Cancel)
        if qMessageBox.exec_() == QtGui.QMessageBox.Ok:
            self.deleteEventInSeisHub(resource_name)
            self.setXMLEventID(event_id)
            self.uploadSeisHub()
            self.on_qToolButton_updateEventList_clicked()
            self.checkForSysopEventDuplicates(self.T0, self.T1)

    def on_qToolButton_deleteEvent_clicked(self, *args):
        if args:
            return
        event = self.seishubEventList[self.seishubEventCurrent]
        resource_name = event.get('resource_name')
        try:
            user = ev.creation_info.author
        except:
            user = None
        qMessageBox = QtGui.QMessageBox()
        qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
        qMessageBox.setIcon(QtGui.QMessageBox.Warning)
        qMessageBox.setWindowTitle("Delete?")
        qMessageBox.setText("Delete event from database?")
        msg = "%s  (user: %s)" % (resource_name, user)
        qMessageBox.setInformativeText(msg)
        qMessageBox.setStandardButtons(QtGui.QMessageBox.Cancel | QtGui.QMessageBox.Ok)
        qMessageBox.setDefaultButton(QtGui.QMessageBox.Cancel)
        if qMessageBox.exec_() == QtGui.QMessageBox.Ok:
            self.deleteEventInSeisHub(resource_name)
            self.on_qToolButton_updateEventList_clicked()
    
    def on_qCheckBox_sysop_toggled(self):
        newstate = self.widgets.qCheckBox_sysop.isChecked()
        if not str(self.widgets.qLineEdit_sysopPassword.text()):
            self.widgets.qCheckBox_sysop.setChecked(False)
            err = "Error: Enter password for \"sysop\"-account first."
            print >> sys.stderr, err
        else:
            print "Setting usage of \"sysop\"-account to: %s" % newstate
    
    # the corresponding signal is emitted when hitting return after entering
    # the password
    def on_qLineEdit_sysopPassword_editingFinished(self):
        passwd = str(self.widgets.qLineEdit_sysopPassword.text())
        tmp_client = self.SClient(base_url=self.server['BaseUrl'],
                                  user="sysop", password=passwd)
        if tmp_client.testAuth():
            self.clients['SeisHub-sysop'] = tmp_client
            self.widgets.qCheckBox_sysop.setChecked(True)
        # if authentication test fails empty password field and uncheck sysop
        else:
            self.clients.pop('SeisHub-sysop', None)
            self.widgets.qCheckBox_sysop.setChecked(False)
            self.widgets.qLineEdit_sysopPassword.clear()
            err = "Error: Authentication as sysop failed! (Wrong password!?)"
            print >> sys.stderr, err
        self.canv.setFocus() # XXX needed??
    # XXX XXX not used atm. relict from gtk when buttons snatch to grab the
    # XXX XXX focus away from the mpl-canvas to which key/mouseButtonPresses are
    # XXX XXX connected
    # XXX def on_buttonSetFocusOnPlot_clicked(self, event):
    # XXX     self.setFocusToMatplotlib()

    def on_qToolButton_debug_clicked(self, *args):
        if args:
            return
        self.debug()
    
    def on_qToolButton_previousStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt - 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_streamName_currentIndexChanged(self, newvalue):
        self.stPt = self.widgets.qComboBox_streamName.currentIndex()
        xmin, xmax = self.axs[0].get_xlim()
        #self.delAllItems()
        self.delAxes()
        self.fig.clear()
        self.drawAxes()
        self.drawAllItems()
        self.multicursorReinit()
        self.axs[0].set_xlim(xmin, xmax)
        self.updatePlot()
        stats = self.streams[self.stPt][0].stats
        print "Going to stream: %s.%s" % (stats.network, stats.station)
        self.updateStreamNumberLabel()

    def on_qToolButton_nextStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt + 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_phaseType_currentIndexChanged(self, newvalue):
        # XXX: Ugly hack because it can be called before the combo box has any
        # entries.
        try:
            self.updateMulticursorColor()
            self.redraw()
        except AttributeError:
            pass

    def on_qToolButton_filter_toggled(self):
        self.updatePlot()

    def on_qToolButton_rotateLQT_toggled(self):
        if self.widgets.qToolButton_rotateLQT.isChecked():
            self.widgets.qToolButton_rotateZRT.setChecked(False)
        self.updatePlot()

    def on_qToolButton_rotateZRT_toggled(self):
        if self.widgets.qToolButton_rotateZRT.isChecked():
            self.widgets.qToolButton_rotateLQT.setChecked(False)
        self.updatePlot()

    def on_qToolButton_trigger_toggled(self):
        self.updatePlot()
        ymax = max([max(abs(p.get_ydata())) for p in self.plts])
        if self.widgets.qToolButton_trigger.isChecked():
            ymin = 0
        else:
            ymin = -ymax
        for ax in self.axs:
            ax.set_ybound(upper=ymax, lower=ymin)
        self.redraw()

    def on_qToolButton_arpicker_clicked(self, *args):
        """
        Set automatic P/S picks using the AR picker.
        """
        if args:
            return
        self.clearDictionaries()
        self.updateAllItems()
        self._arpicker()
        self.updateAllItems()
        self.redraw()
        
    def on_qComboBox_filterType_currentIndexChanged(self, newvalue):
        if self.widgets.qToolButton_filter.isChecked():
            self.updatePlot()

    def on_qCheckBox_zerophase_toggled(self):
        if self.widgets.qToolButton_filter.isChecked():
            self.updatePlot()

    def on_qDoubleSpinBox_highpass_valueChanged(self, newvalue):
        widgets = self.widgets
        stats = self.streams[self.stPt][0].stats
        if not widgets.qToolButton_filter.isChecked() or \
           str(widgets.qComboBox_filterType.currentText()) == "Lowpass":
            self.canv.setFocus() # XXX needed??
            return
        # if the filter flag is not set, we don't have to update the plot
        # XXX if we have a lowpass, we dont need to update!! Not yet implemented!! XXX
        if widgets.qDoubleSpinBox_lowpass.value() < newvalue:
            err = "Warning: Lowpass frequency below Highpass frequency!"
            print >> sys.stderr, err
        # XXX maybe the following check could be done nicer
        # XXX check this criterion!
        minimum  = float(stats.sampling_rate) / stats.npts
        if newvalue < minimum:
            err = "Warning: Lowpass frequency is not supported by length of trace!"
            print >> sys.stderr, err
        self.updatePlot()
        # XXX we could use this for the combobox too!
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed?? # XXX do we still need this focus grabbing with QT??? XXX XXX XXX XXX

    def on_qDoubleSpinBox_lowpass_valueChanged(self, newvalue):
        widgets = self.widgets
        stats = self.streams[self.stPt][0].stats
        if not widgets.qToolButton_filter.isChecked() or \
           str(widgets.qComboBox_filterType.currentText()) == "Highpass":
            self.canv.setFocus() # XXX needed??
            return
        # if the filter flag is not set, we don't have to update the plot
        # XXX if we have a highpass, we dont need to update!! Not yet implemented!! XXX
        if newvalue < widgets.qDoubleSpinBox_highpass.value():
            err = "Warning: Lowpass frequency below Highpass frequency!"
            print >> sys.stderr, err
        # XXX maybe the following check could be done nicer
        # XXX check this criterion!
        maximum  = stats.sampling_rate / 2.0 # Nyquist
        if newvalue > maximum:
            err = "Warning: Highpass frequency is lower than Nyquist!"
            print >> sys.stderr, err
        self.updatePlot()
        # XXX we could use this for the combobox too!
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed??

    def on_qDoubleSpinBox_sta_valueChanged(self, newvalue):
        widgets = self.widgets
        # if the trigger flag is not set, we don't have to update the plot
        if not widgets.qToolButton_trigger.isChecked():
            self.canv.setFocus() # XXX needed??
            return
        self.updatePlot()
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed?? # XXX do we still need this focus grabbing with QT??? XXX XXX XXX XXX

    def on_qDoubleSpinBox_lta_valueChanged(self, newvalue):
        widgets = self.widgets
        # if the trigger flag is not set, we don't have to update the plot
        if not widgets.qToolButton_trigger.isChecked():
            self.canv.setFocus() # XXX needed??
            return
        self.updatePlot()
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed?? # XXX do we still need this focus grabbing with QT??? XXX XXX XXX XXX

    def on_qToolButton_spectrogram_toggled(self):
        state = self.widgets.qToolButton_spectrogram.isChecked()
        widgets_deactivate = ("qToolButton_filter", "qToolButton_overview",
                "qComboBox_filterType", "qCheckBox_zerophase",
                "qLabel_highpass", "qLabel_lowpass", "qDoubleSpinBox_highpass",
                "qDoubleSpinBox_lowpass", "qToolButton_rotateLQT",
                "qToolButton_rotateZRT", "qToolButton_trigger")
        for name in widgets_deactivate:
            widget = getattr(self.widgets, name)
            widget.setEnabled(not state)
        if state:
            msg = "Showing spectrograms (takes a few seconds with log-option)."
        else:
            msg = "Showing seismograms."
        print msg
        xmin, xmax = self.axs[0].get_xlim()
        #self.delAllItems()
        self.delAxes()
        self.fig.clear()
        self.drawAxes()
        self.drawAllItems()
        self.multicursorReinit()
        self.axs[0].set_xlim(xmin, xmax)
        self.updatePlot()

    def on_qCheckBox_spectrogramLog_toggled(self):
        if self.widgets.qToolButton_spectrogram.isChecked():
            self.on_qToolButton_spectrogram_toggled()

    def on_qDoubleSpinBox_wlen_valueChanged(self):
        if self.widgets.qToolButton_spectrogram.isChecked():
            self.on_qToolButton_spectrogram_toggled()

    def on_qDoubleSpinBox_perlap_valueChanged(self):
        if self.widgets.qToolButton_spectrogram.isChecked():
            self.on_qToolButton_spectrogram_toggled()

    ###########################################################################
    ### signal handlers END ###### ############################################
    ###########################################################################

    def _filter(self, stream):
        """
        Applies filter currently selected in GUI to Trace or Stream object.
        Also displays a message.
        """
        w = self.widgets
        type = str(w.qComboBox_filterType.currentText()).lower()
        options = {}
        options['corners'] = 1
        options['zerophase'] = w.qCheckBox_zerophase.isChecked()
        if type in ("bandpass", "bandstop"):
            options['freqmin'] = w.qDoubleSpinBox_highpass.value()
            options['freqmax'] = w.qDoubleSpinBox_lowpass.value()
        elif type == "lowpass":
            options['freq'] = w.qDoubleSpinBox_lowpass.value()
        elif type == "highpass":
            options['freq'] = w.qDoubleSpinBox_highpass.value()
        if type in ("bandpass", "bandstop"):
            msg = "%s (zerophase=%s): %.2f-%.2f Hz" % \
                    (type, options['zerophase'],
                     options['freqmin'], options['freqmax'])
        elif type in ("lowpass", "highpass"):
            msg = "%s (zerophase=%s): %.2f Hz" % \
                    (type, options['zerophase'], options['freq'])
        try:
            stream.detrend("linear")
            stream.taper()
            stream.filter(type, **options)
            print msg
        except:
            err = "Error during filtering. Showing unfiltered data."
            print >> sys.stderr, err

    def _rotateLQT(self, stream, origin):
        """
        Rotates stream to LQT with respect to station location in first trace
        of stream and origin information.
        Exception handling should be done outside this function.
        Also displays a message.
        """
        # calculate backazimuth and incidence from station/event geometry
        azim, bazim, inci = coords2azbazinc(stream, origin)
        # replace ZNE data with rotated data
        z = stream.select(component="Z")[0].data
        n = stream.select(component="N")[0].data
        e = stream.select(component="E")[0].data
        print "using baz, inci:", bazim, inci
        l, q, t = rotate_ZNE_LQT(z, n, e, bazim, inci)
        stream.select(component="Z")[0].data = l
        stream.select(component="N")[0].data = q
        stream.select(component="E")[0].data = t
        print "Showing traces rotated to LQT."

    def _rotateZRT(self, stream, origin):
        """
        Rotates stream to ZRT with respect to station location in first trace
        of stream and origin information.
        Exception handling should be done outside this function.
        Also displays a message.
        """
        # calculate backazimuth from station/event geometry
        azim, bazim, inci = coords2azbazinc(stream, origin)
        # replace NE data with rotated data
        n = stream.select(component="N")[0].data
        e = stream.select(component="E")[0].data
        print "using baz:", bazim
        r, t = rotate_NE_RT(n, e, bazim)
        stream.select(component="N")[0].data = r
        stream.select(component="E")[0].data = t
        print "Showing traces rotated to ZRT."

    def _trigger(self, stream):
        """
        Run recSTALTA trigger on stream/trace.
        Exception handling should be done outside this function.
        Also displays a message.
        """
        sta = self.widgets.qDoubleSpinBox_sta.value()
        lta = self.widgets.qDoubleSpinBox_lta.value()
        stream.trigger("recstalta", sta=sta, lta=lta)
        print "Showing recSTALTA triggered traces."

    def _arpicker(self):
        """
        Run AR picker on all streams and set P/S picks accordingly.
        Also displays a message.
        """
        f1 = self.options.ar_f1
        f2 = self.options.ar_f2
        sta_p = self.options.ar_sta_p
        lta_p = self.options.ar_lta_p
        sta_s = self.options.ar_sta_s
        lta_s = self.options.ar_lta_s
        m_p = self.options.ar_m_p
        m_s = self.options.ar_m_s
        l_p = self.options.ar_l_p
        l_s = self.options.ar_l_s
        print "Setting automatic picks using AR picker:"
        for i, st in enumerate(self.streams):
            z = st.select(component="Z")[0].data
            n = st.select(component="N")[0].data
            e = st.select(component="E")[0].data
            spr = st[0].stats.sampling_rate
            p, s = arPick(z, n, e, spr, f1, f2, lta_p, sta_p, lta_s, sta_s,
                          m_p, m_s, l_p, l_s)
            net = st[0].stats.network
            sta = st[0].stats.station
            print "%s.%s: P set at %.3f (%s)" % (net, sta, p, self.time_rel2abs(p))
            print "%s.%s: S set at %.3f (%s)" % (net, sta, s, self.time_rel2abs(s))
            d = self.dicts[i]
            d['P'] = p
            d['S'] = s
            for key in ['P', 'S']:
                self.updateLine(key)
                self.updateLabel(key)
        return            

    def debug(self):
        sys.stdout = self.stdout_backup
        sys.stderr = self.stderr_backup
        ## DEBUG PYQT START
        QtCore.pyqtRemoveInputHook()
        try:
            from IPython.core.debugger import Tracer
            Tracer(colors="Linux")()
        except ImportError:
            import pdb
            pdb.set_trace()
        QtCore.pyqtRestoreInputHook()
        ## DEBUG PYQT END
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)

    def setFocusToMatplotlib(self):
        self.canv.setFocus() # XXX needed??

    def drawPickLabel(self, ax, pick):
        """
        Draws Labels at pick axvlines.
        """
        label = '  ' + pick.get("phase_hint", "_") + ":"
        label += ONSET_CHARS.get(pick.onset, "?")
        label += POLARITY_CHARS.get(pick.polarity, "?")
        # XXX TODO check handling of custom int weights
        if "extra" in pick:
            weight = pick.extra.get("weight", {"value": "_"})
            label += str(weight["value"])
        else:
            label += "_"
        x = self.time_abs2rel(pick.time)
        y = 1 - 0.01 * len(self.axs)
        i = self.axs.index(ax)
        color = PHASE_COLORS[pick.phase_hint]
        ax.text(x, y, label, transform=self.trans[i], color=color,
                family='monospace', va="top")

    def drawArrivalLabel(self, ax, arrival, pick):
        """
        Draw the label for an arrival.
        """
        label = '  %s %+.3fs' % (arrival.phase, arrival.time_residual)
        x = self.time_abs2rel(pick.time) + arrival.time_residual
        y = 1 - 0.03 * len(self.axs)
        i = self.axs.index(ax)
        ax.text(x, y, label, transform=self.trans[i], color='k',
                family='monospace', va="top")
    
    def updateLabel(self, key):
        self.delLabel(key)
        self.drawLabel(key)

    def drawIds(self):
        """
        draws the trace ids plotted as text into each axes.
        """
        # make a Stream with the traces that are plotted
        if self.widgets.qToolButton_overview.isChecked():
            tmp_stream = Stream([st.select(component="Z")[0] for st in self.streams])
        else:
            tmp_stream = self.streams[self.stPt]
        for ax, tr in zip(self.axs, tmp_stream):
            ax.text(0.01, 0.95, tr.id, va="top", ha="left", fontsize=18,
                    family='monospace', color="blue", zorder=10000,
                    transform=ax.transAxes)

    def updateIds(self, textcolor):
        """
        updates the trace ids plotted as text into each axes.
        if "rotate" button is on map the component key to LQT or ZRT.
        CAUTION: The last letter of the ID plotted here is used to identify
                 the component when setting S polarities!!
                 Change with caution!!
        """
        # make a Stream with the traces that are plotted
        # if in overview mode this is not one of the original streams but a
        # stream with all the Z traces of all streams
        if self.widgets.qToolButton_overview.isChecked():
            tmp_stream = Stream([st.select(component="Z")[0] for st in self.streams])
        else:
            tmp_stream = self.streams[self.stPt]
        for ax, tr in zip(self.axs, tmp_stream):
            tr_id = tr.id
            # if a rotate button is on: change trace id's component character
            if self.widgets.qToolButton_rotateLQT.isChecked() or \
                    self.widgets.qToolButton_rotateZRT.isChecked():
                # which mapping of component keys to use?
                if self.widgets.qToolButton_rotateLQT.isChecked():
                    comp_map = ROTATE_LQT_COMP_MAP
                elif self.widgets.qToolButton_rotateZRT.isChecked():
                    comp_map = ROTATE_ZRT_COMP_MAP
                # do the component key mapping
                if tr_id[-1].isalpha():
                    tr_id = tr_id[:-1] + comp_map[tr_id[-1]]
                else:
                    tr_id += comp_map[tr_id[-1]]
            # if trigger button is on: add to trace ids
            if self.widgets.qToolButton_trigger.isChecked():
                tr_id += " (recSTALTA)"
            # trace ids are first text-plot so its at position 0
            t = ax.texts[0]
            t.set_text(tr_id)
            t.set_color(textcolor)

    def delKey(self, key):
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        del dict[key]
        print "%s deleted." % KEY_FULLNAMES[key]
        # we have to take care of some special cases:
        if key == 'S':
            pass
        elif key in ['MagMin1', 'MagMax1', 'MagMin2', 'MagMax2']:
            key2 = key + 'T'
            del dict[key2]
    
    def drawAxes(self):
        st = self.getCurrentStream()
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        self.t = t
        for i, tr in enumerate(st):
            if i == 0:
                ax = fig.add_subplot(len(st), 1, 1)
            else:
                ax = fig.add_subplot(len(st), 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax) 
            # relative x-axis times start with 0 at global reference time
            starttime_relative = self.time_abs2rel(tr.stats.starttime)
            sampletimes = np.arange(starttime_relative,
                    starttime_relative + (tr.stats.delta * tr.stats.npts),
                    tr.stats.delta)
            # XXX sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData,
                                                                         ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            if self.widgets.qToolButton_spectrogram.isChecked():
                log = self.widgets.qCheckBox_spectrogramLog.isChecked()
                wlen = self.widgets.qDoubleSpinBox_wlen.value()
                perlap = self.widgets.qDoubleSpinBox_perlap.value()
                spectrogram(tr.data, tr.stats.sampling_rate, log=log, wlen=wlen, per_lap=perlap,
                            cmap=self.spectrogramColormap, axes=ax, zorder=-10)
                textcolor = "red"
            else:
                # normalize with overall sensitivity and convert to nm/s
                # if not explicitly deactivated on command line
                if not self.options.nonormalization and not self.options.nometadata:
                    plts.append(ax.plot(sampletimes, tr.data / tr.stats.paz.sensitivity * 1e9, color='k', zorder=1000)[0])
                else:
                    plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
                textcolor = "blue"
        self.drawIds()
        axs[-1].xaxis.set_ticks_position("both")
        label = self.T0.isoformat().replace("T", "  ")
        self.supTit = fig.suptitle(label, ha="left", va="bottom",
                                   x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)
    
    def delAxes(self):
        for ax in self.axs:
            if ax in self.fig.axes: 
                self.fig.delaxes(ax)
            del ax
        if self.supTit in self.fig.texts:
            self.fig.texts.remove(self.supTit)
    
    def redraw(self):
        for line in self.multicursor.lines:
            line.set_visible(False)
        self.canv.draw()
    
    def updatePlot(self):
        """
        Update plot either with raw data or filter data and use filtered data.
        Depending on status of "Filter" Button. Also check "Rotate" buttons if
        data should be rotated to LQT or ZRT coordinates.
        """
        # XXX copying is only necessary if "Filter" or "Rotate" is selected
        # XXX it is simpler for teh code to just copy in any case..
        st = self.streams[self.stPt].copy()
        d = self.dicts[self.stPt]
        # To display filtered data we overwrite our alias to current stream
        # and replace it with the filtered data.
        if self.widgets.qToolButton_filter.isChecked():
            self._filter(st)
        else:
            print "Unfiltered Traces."
        # check if rotation should be performed
        if self.widgets.qToolButton_rotateLQT.isChecked():
            try:
                # XXX TODO needs fixing:
                self._rotateLQT(st, self.dictOrigin)
            except Exception, e:
                self.widgets.qToolButton_rotateLQT.setChecked(False)
                err = str(e)
                err += "\nError during rotating to LQT. Showing unrotated data."
                print >> sys.stderr, err
        elif self.widgets.qToolButton_rotateZRT.isChecked():
            try:
                # XXX TODO needs fixing:
                self._rotateZRT(st, self.dictOrigin)
            except Exception, e:
                self.widgets.qToolButton_rotateZRT.setChecked(False)
                err = str(e)
                err += "\nError during rotating to ZRT. Showing unrotated data."
                print >> sys.stderr, err
        # check if trigger should be performed
        if self.widgets.qToolButton_trigger.isChecked():
            try:
                self._trigger(st)
            except:
                self.widgets.qToolButton_trigger.setChecked(False)
                err = "Error during triggering. Showing waveform data."
                print >> sys.stderr, err
                
        self.updateIds("blue")
        self.redraw()
            
        # Update all plots' y data
        for tr, plot in zip(st, self.plts):
            plot.set_ydata(tr.data)
        self.redraw()

    # Define the event that handles the setting of P- and S-wave picks
    # XXX prefix with underscores to avoid autoconnect to Qt
    def __mpl_keyPressEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        keys = self.keys
        phase_type = str(self.widgets.qComboBox_phaseType.currentText())
        dict = self.getCurrentDict()
        st = self.getCurrentStream()
        
        #######################################################################
        # Start of key events related to picking                              #
        #######################################################################
        # For some key events (picking events) we need information on the x/y
        # position of the cursor:
        if ev.key in [keys['setPick'], keys['setPickError'],
                      keys['setMagMin'], keys['setMagMax']]:
            # some keyPress events only make sense inside our matplotlib axes
            if ev.inaxes not in self.axs:
                return
            # get the correct sample times array for the click
            t = self.t[self.axs.index(ev.inaxes)]
            tr = st[self.axs.index(ev.inaxes)]
            # We want to round from the picking location to
            # the time value of the nearest sample:
            samp_rate = st[0].stats.sampling_rate
            pickSample = (ev.xdata - t[0]) * samp_rate
            print pickSample
            pickSample = round(pickSample)
            print pickSample
            # we need the position of the cursor location
            # in the seismogram array:
            xpos = pickSample
            # Determine the time of the nearest sample
            pickSample = t[pickSample]
            print pickSample
            print ev.inaxes.lines[0].get_ydata()[xpos]

        if ev.key == keys['setPick']:
            if phase_type in SEISMIC_PHASES:
                pick = self.getPick(axes=ev.inaxes, phase_hint=phase_type, setdefault=True, seed_string=tr.id)
                print ev.inaxes, self.axs, phase_type, tr.id
                print pick
                pick.setTime(self.time_rel2abs(pickSample))
                #self.updateAxes(ev.inaxes)
                self.updateAllAxes()
                self.redraw()
                print "%s set at %.3f (%s)" % (KEY_FULLNAMES[phase_type],
                                               self.time_abs2rel(pick.time),
                                               pick.time.isoformat())
                net = pick.waveform_id.network_code
                sta = pick.waveform_id.station_code
                phase_hint2 = None
                if pick.phase_hint == "P":
                    phase_hint2 = "S"
                elif pick.phase_hint == "S":
                    phase_hint2 = "P"
                if phase_hint2:
                    pick2 = self.getPick(network=net, station=sta,
                                         phase_hint=phase_hint2)
                    if pick2:
                        print "S-P time: %.3f" % abs(pick.time - pick2.time)
                return

        if ev.key in keys['setWeight'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Weight"
                dict[key] = keys['setWeight'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %i" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setPol'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Pol"
                dict[key] = keys['setPol'][ev.key]
                # map SH/SV polarities if rotated to ZRT
                if phase_type == "S":
                    try:
                        comp = ev.inaxes.texts[0].get_text()[-1].upper()
                        dict[key] = S_POL_MAP_ZRT[comp][dict[key]]
                        print "setting polarity for %s" % S_POL_PHASE_TYPE[comp]
                    except:
                        err = "Warning: to map up/down polarity to SH/SV " + \
                              "equivalents rotate to ZRT and place mouse " + \
                              "over R or T axes."
                        print >> sys.stderr, err
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setOnset'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Onset"
                dict[key] = keys['setOnset'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key == keys['delPick']:
            if phase_type in SEISMIC_PHASES:
                pick = self.getPick(axes=ev.inaxes, phase_hint=phase_type)
                self.delPick(pick)
                self.updateAllAxes()
                self.redraw()
                return

        if ev.key == keys['setPickError']:
            if phase_type in SEISMIC_PHASES:
                pick = self.getPick(axes=ev.inaxes, phase_hint=phase_type)
                if not pick:
                    return
                pick.setErrorTime(self.time_rel2abs(pickSample))
                self.updateAllAxes()
                self.redraw()
                print "Error %s set at %s" % (KEY_FULLNAMES[phase_type],
                                        self.time_rel2abs(pickSample).isoformat())
                return

        if ev.key in (keys['setMagMin'], keys['setMagMax']):
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs:
                return
            if phase_type == 'Mag':
                ampl = self.getAmplitude(axes=ev.inaxes, setdefault=True, seed_string=tr.id)
                # do the actual work
                ydata = ev.inaxes.lines[0].get_ydata() #get the first line hoping that it is the seismogram!
                cutoffSamples = xpos - MAG_PICKWINDOW #remember, how much samples there are before our small window! We have to add this number for our MagMinT estimation!
                if ev.key == keys['setMagMin']:
                    val = np.min(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                    tmp_magtime = cutoffSamples + np.argmin(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                elif ev.key == keys['setMagMax']:
                    val = np.max(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                    tmp_magtime = cutoffSamples + np.argmax(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                # XXX GSE calib handling! special handling for GSE2 data: apply calibration
                if tr.stats._format == "GSE2":
                    val = val / (tr.stats.calib * 2 * np.pi / tr.stats.gse2.calper)
                # save time of magnitude minimum in seconds
                tmp_magtime = self.time_rel2abs(tmp_magtime / samp_rate)
                if ev.key == keys['setMagMin']:
                    ampl.setLow(tmp_magtime, val)
                elif ev.key == keys['setMagMax']:
                    ampl.setHigh(tmp_magtime, val)
                self.updateAllAxes()
                self.redraw()
                return

        if ev.key == keys['delMagMinMax']:
            if phase_type == 'Mag':
                ampl = self.getAmplitude(axes=ev.inaxes)
                self.delAmplitude(ampl)
                self.updateAllAxes()
                self.redraw()
                return
        #######################################################################
        # End of key events related to picking                                #
        #######################################################################
        
        if ev.key == keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = True

        # iterate the phase type combobox
        if ev.key == keys['switchPhase']:
            combobox = self.widgets.qComboBox_phaseType
            next = (combobox.currentIndex() + 1) % combobox.count()
            combobox.setCurrentIndex(next)
            print "Switching Phase button"
            return
            
        if ev.key == keys['prevStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_previousStream_clicked()
            return

        if ev.key == keys['nextStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_nextStream_clicked()
            return
    
    def __mpl_keyReleaseEvent(self, ev):
        if ev.key == self.keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = False

    # Define zooming for the mouse wheel wheel
    def __mpl_wheelEvent(self, ev):
        # create mpl event from QEvent to get cursor position in data coords
        x = ev.x()
        y = self.canv.height() - ev.y()
        mpl_ev = MplMouseEvent("scroll_event", self.canv, x, y, "up", guiEvent=ev)
        # Calculate and set new axes boundaries from old ones
        if self.widgets.qToolButton_showMap.isChecked():
            ax = self.axEventMap
        else:
            ax = self.axs[0]
        (left, right) = ax.get_xbound()
        (bottom, top) = ax.get_ybound()
        # Get the keyboard modifiers. They are a enum type.
        # Use bitwise or to compare...hope this is correct.
        if ev.modifiers() == QtCore.Qt.NoModifier:
            # Zoom in.
            if ev.delta() < 0:
                left -= (mpl_ev.xdata - left) / 2
                right += (right - mpl_ev.xdata) / 2
                if self.widgets.qToolButton_showMap.isChecked():
                    top -= (mpl_ev.ydata - top) / 2
                    bottom += (bottom - mpl_ev.ydata) / 2
            # Zoom out.
            elif ev.delta() > 0:
                left += (mpl_ev.xdata - left) / 2
                right -= (right - mpl_ev.xdata) / 2
                if self.widgets.qToolButton_showMap.isChecked():
                    top += (mpl_ev.ydata - top) / 2
                    bottom -= (bottom - mpl_ev.ydata) / 2
        # Still able to use the dictionary.
        elif ev.modifiers() == getattr(QtCore.Qt,
                '%sModifier' % self.keys['switchWheelZoomAxis'].capitalize()):
            if self.widgets.qToolButton_spectrogram.isChecked():
            # Zoom in on wheel-up
                if ev.delta() < 0:
                    top -= (mpl_ev.ydata - top) / 2
                    bottom += (bottom - mpl_ev.ydata) / 2
                # Zoom out on wheel-down
                elif ev.delta() > 0:
                    top += (mpl_ev.ydata - top) / 2
                    bottom -= (bottom - mpl_ev.ydata) / 2
            else:
            # Zoom in on wheel-up
                if ev.delta() < 0:
                    top *= 2
                    bottom *= 2
                # Zoom out on wheel-down
                elif ev.delta() > 0:
                    top /= 2
                    bottom /= 2
        ax.set_xbound(lower=left, upper=right)
        ax.set_ybound(lower=bottom, upper=top)
        self.redraw()
    
    # Define zoom reset for the mouse button 2 (always wheel wheel!?)
    def __mpl_mouseButtonPressEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        # set widgetlock when pressing mouse buttons and dont show cursor
        # cursor should not be plotted when making a zoom selection etc.
        if ev.button in [1, 3]:
            self.multicursor.visible = False
            # reuse this event as setPick / setPickError event
            if ev.button == 1:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPick']
                else:
                    ev.key = self.keys['setMagMin']
            elif ev.button == 3:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPickError']
                else:
                    ev.key = self.keys['setMagMax']
            self.__mpl_keyPressEvent(ev)
            # XXX self.canv.widgetlock(self.toolbar)
        # show traces from start to end
        # (Use Z trace limits as boundaries)
        elif ev.button == 2:
            if self.widgets.qToolButton_showMap.isChecked():
                ax = self.axEventMap
            else:
                ax = self.axs[0]
            ax.set_xbound(lower=self.xMin, upper=self.xMax)
            ax.set_ybound(lower=self.yMin, upper=self.yMax)
            # Update all subplots
            self.redraw()
            print "Resetting axes"
    
    def __mpl_mouseButtonReleaseEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        # release widgetlock when releasing mouse buttons
        if ev.button in [1, 3]:
            self.multicursor.visible = True
            # XXX self.canv.widgetlock.release(self.toolbar)

    def __mpl_motionNotifyEvent(self, ev):
        try:
            if ev.inaxes in self.axs:
                self.widgets.qLabel_xdata_rel.setText(formatXTicklabels(ev.xdata))
                label = self.time_rel2abs(ev.xdata).isoformat().replace("T", "  ")[:-3]
                self.widgets.qLabel_xdata_abs.setText(label)
                self.widgets.qLabel_ydata.setText("%.1f" % ev.ydata)
            else:
                self.widgets.qLabel_xdata_rel.setText("")
                self.widgets.qLabel_xdata_abs.setText(str(ev.xdata))
                self.widgets.qLabel_ydata.setText(str(ev.ydata))
        except TypeError:
            pass
    
    #lookup multicursor source: http://matplotlib.sourcearchive.com/documentation/0.98.1/widgets_8py-source.html
    def multicursorReinit(self):
        self.canv.mpl_disconnect(self.multicursor.id1)
        self.canv.mpl_disconnect(self.multicursor.id2)
        self.multicursor.__init__(self.canv, self.axs, useblit=True,
                                  color='black', linewidth=1, ls='dotted')
        self.updateMulticursorColor()
        # XXX self.canv.widgetlock.release(self.toolbar)

    def updateMulticursorColor(self):
        phase_name = str(self.widgets.qComboBox_phaseType.currentText())
        color = PHASE_COLORS[phase_name]
        for l in self.multicursor.lines:
            l.set_color(color)

    def updateStreamNumberLabel(self):
        label = "%02i/%02i" % (self.stPt + 1, self.stNum)
        self.widgets.qLabel_streamNumber.setText(label)
    
    def updateStreamNameCombobox(self):
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def updateStreamLabels(self):
        self.updateStreamNumberLabel()
        self.updateStreamNameCombobox()

    def load3dlocSyntheticPhases(self):
        msg = "Not updated after massive QuakeML restructuring."
        raise NotImplementedError(msg)

    def do3dLoc(self):
        msg = "Not updated after massive QuakeML restructuring."
        raise NotImplementedError(msg)

    def doFocmec(self):
        prog_dict = PROGRAMS['focmec']
        files = prog_dict['files']
        f = open(files['phases'], 'wt')
        f.write("\n") #first line is ignored!
        #Fortran style! 1: Station 2: Azimuth 3: Incident 4: Polarity
        #fmt = "ONTN  349.00   96.00C"
        fmt = "%4s  %6.2f  %6.2f%1s\n"
        count = 0
        for pick in self.picks:
            arrival = getArrivalForPick(self.event, pick)
            if not arrival:
                continue
            pt = pick.phase_hint
            if pick.polarity is None or arrival.azimuth is None or arrival.takeoff_angle is None:
                continue
            sta = pick.waveform_id.station_code[:4] #focmec has only 4 chars
            # XXX commenting the following out again
            # XXX only polarities with Azim/Inci info from location used
            #if pt + 'Azim' not in dict or pt + 'Inci' not in dict:
            #    azim, bazim, inci = coords2azbazinc(st, self.dictOrigin)
            #    err = "Warning: No azimuth/incidence information for " + \
            #          "phase pick found, using azimuth/incidence from " + \
            #          "source/receiver geometry."
            #    print >> sys.stderr, err
            # XXX hack for nonlinloc: they return different angles:
            # XXX they use takeoff dip instead of incidence
            #elif self.dictOrigin['Program'] == "NLLoc":
            #    azim, bazim, inci = coords2azbazinc(st, self.dictOrigin)
            #    err = "Warning: Location program is nonlinloc, " + \
            #          "returning takeoff angles instead of incidence " + \
            #          "angles. Using azimuth/incidence from " + \
            #          "source/receiver geometry."
            #    print >> sys.stderr, err
            #else:
            azim = arrival.azimuth
            inci = arrival.takeoff_angle
            pol = pick.polarity
            try:
                pol = POLARITY_2_FOCMEC[pol]
            except:
                err = "Error: Failed to map polarity information to " + \
                      "FOCMEC identifier (%s, %s, %s), skipping."
                err = err % (dict['Station'], pt, pol)
                print >> sys.stderr, err
                continue
            count += 1
            f.write(fmt % (sta, azim, inci, pol))
        f.close()
        print 'Phases for focmec: %i' % count
        self.catFile(files['phases'])
        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict)
        print msg
        print >> sys.stderr, err
        if returncode == 1:
            err = "Error: focmec did not find a suitable solution!"
            print >> sys.stderr, err
            return
        print '--> focmec finished'
        lines = open(files['summary'], "rt").readlines()
        print '%i suitable solutions found:' % len(lines)
        self.focMechList = []
        for line in lines:
            line = line.split()
            np1 = NodalPlane()
            np = NodalPlanes(nodal_plane_1=np1)
            fm = FocalMechanism(nodal_planes=np)
            fm.method_id = "/".join([ID_ROOT, "focal_mechanism_method", "focmec", "1"])
            np1.dip = float(line[0])
            np1.strike = float(line[1])
            np1.rake = float(line[2])
            fm.station_polarity_count = count
            errors = sum([int(float(line[no])) for no in (3, 4, 5)]) # not used in xml
            fm.misfit = errors / float(fm.station_polarity_count)
            fm.comments.append(Comment("Possible Solution Count: %i" % len(lines)))
            print "Strike: %6.2f  Dip: %6.2f  Rake: %6.2f  Misfit: %.2f" % \
                    (np1.strike, np1.dip, np1.rake, fm.misfit)
            self.focMechList.append(fm)
        self.focMechCount = len(self.focMechList)
        self.focMechCurrent = 0
        print "selecting Focal Mechanism No.  1 of %2i:" % self.focMechCount
        self.focalMechanism = self.focMechList[0]
        fm = self.focalMechanism
        np1 = fm.nodal_planes.nodal_plane_1
        print "Strike: %6.2f  Dip: %6.2f  Rake: %6.2f  Misfit: %.2f" % \
                (np1.strike, np1.dip, np1.rake, fm.misfit)

    def nextFocMec(self):
        if self.focMechCount is None:
            return
        self.focMechCurrent = (self.focMechCurrent + 1) % self.focMechCount
        self.focalMechanism = self.focMechList[self.focMechCurrent]
        fm = self.focalMechanism
        np1 = fm.nodal_planes.nodal_plane_1
        print "selecting Focal Mechanism No. %2i of %2i:" % \
                (self.focMechCurrent + 1, self.focMechCount)
        print "Strike: %6.2f  Dip: %6.2f  Rake: %6.2f  Misfit: %.2f" % \
                (np1.strike, np1.dip, np1.rake, fm.misfit)
    
    def drawFocMec(self):
        if not self.focalMechanism:
            err = "Error: No focal mechanism data!"
            print >> sys.stderr, err
            return
        # make up the figure:
        fig = self.fig
        self.axsFocMec = []
        axs = self.axsFocMec
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1)
        
        # plot the selected solution
        fm = self.focalMechanism
        np1 = fm.nodal_planes.nodal_plane_1
        axs.append(Beachball([np1.strike, np1.dip, np1.rake], fig=fig))
        # plot the alternative solutions
        if self.focMechList != []:
            for _fm in self.focMechList:
                _np1 = _fm.nodal_planes.nodal_plane_1
                axs.append(Beachball([_np1.strike, _np1.dip, _np1.rake],
                          nofill=True, fig=fig, edgecolor='k',
                          linewidth=1., alpha=0.3))
        text = "Focal Mechanism (%i of %i)" % \
               (self.focMechCurrent + 1, self.focMechCount)
        text += "\nStrike: %6.2f  Dip: %6.2f  Rake: %6.2f" % \
                (np1.strike, np1.dip, np1.rake)
        if fm.misfit:
            text += "\nMisfit: %.2f" % fm.misfit
        if fm.station_polarity_count:
            text += "\nStation Polarity Count: %i" % fm.station_polarity_count
        #fig.canvas.set_window_title("Focal Mechanism (%i of %i)" % \
        #        (self.focMechCurrent + 1, self.focMechCount))
        fig.subplots_adjust(top=0.88) # make room for suptitle
        # values 0.02 and 0.96 fit best over the outer edges of beachball
        #ax = fig.add_axes([0.00, 0.02, 1.00, 0.96], polar=True)
        self.axFocMecStations = fig.add_axes([0.00,0.02,1.00,0.84], polar=True)
        ax = self.axFocMecStations
        ax.set_title(text)
        ax.set_axis_off()
        for dict, st in zip(self.dicts, self.streams):
            net = st[0].stats.network
            sta = st[0].stats.station
            pick = self.getPick(network=net, station=sta, phase_hint='P')
            arrival = getArrivalForPick(self.event, pick)
            if not pick:
                continue
            if pick.polarity is None or arrival.azimuth is None or arrival.takeoff_angle is None:
                continue
            if pick.polarity == "positive":
                color = "black"
            elif pick.polarity == "negative":
                color = "white"
            else:
                color = "red"
            azim = arrival.azimuth
            inci = arrival.takeoff_angle
            # lower hemisphere projection
            if inci > 90:
                inci = 180. - inci
                azim = -180. + azim
            #we have to hack the azimuth because of the polar plot
            #axes orientation
            plotazim = (np.pi / 2.) - ((azim / 180.) * np.pi)
            ax.scatter([plotazim], [inci], facecolor=color)
            ax.text(plotazim, inci, " " + sta, va="top")
        #this fits the 90 degree incident value to the beachball edge best
        ax.set_ylim([0., 91])
        self.canv.draw()

    def delFocMec(self):
        if hasattr(self, "axFocMecStations"):
            self.fig.delaxes(self.axFocMecStations)
            del self.axFocMecStations
        if hasattr(self, "axsFocMec"):
            for ax in self.axsFocMec:
                if ax in self.fig.axes: 
                    self.fig.delaxes(ax)
                del ax

    def doHyp2000(self):
        """
        Writes input files for hyp2000 and starts the hyp2000 program via a
        system call.
        """
        prog_dict = PROGRAMS['hyp_2000']
        files = prog_dict['files']
        #self.setXMLEventID()
        precall = prog_dict['PreCall']
        precall(prog_dict)

        f = open(files['phases'], 'wt')
        phases_hypo71 = self.dicts2hypo71Phases()
        f.write(phases_hypo71)
        f.close()

        f2 = open(files['stations'], 'wt')
        stations_hypo71 = self.dicts2hypo71Stations()
        f2.write(stations_hypo71)
        f2.close()

        print 'Phases for Hypo2000:'
        self.catFile(files['phases'])
        print 'Stations for Hypo2000:'
        self.catFile(files['stations'])

        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict)
        print msg
        print >> sys.stderr, err
        print '--> hyp2000 finished'
        self.catFile(files['summary'])

    def doNLLoc(self):
        """
        Writes input files for NLLoc and starts the NonLinLoc program via a
        system call.
        """
        prog_dict = PROGRAMS['nlloc']
        files = prog_dict['files']
        # determine which model should be used in location
        controlfilename = "locate_%s.nlloc" % \
                          str(self.widgets.qComboBox_nllocModel.currentText())

        #self.setXMLEventID()
        precall = prog_dict['PreCall']
        precall(prog_dict)

        f = open(files['phases'], 'wt')
        #phases_hypo71 = self.dicts2hypo71Phases()
        #f.write(phases_hypo71)
        phases_nlloc = self.dicts2NLLocPhases()
        f.write(phases_nlloc)
        f.close()

        print 'Phases for NLLoc:'
        self.catFile(files['phases'])

        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict, controlfilename)
        print msg
        print >> sys.stderr, err
        print '--> NLLoc finished'
        self.catFile(files['summary'])

    def catFile(self, file):
        lines = open(file, "rt").readlines()
        msg = ""
        for line in lines:
            msg += line
        print msg

    def loadNLLocOutput(self):
        files = PROGRAMS['nlloc']['files']
        lines = open(files['summary'], "rt").readlines()
        if not lines:
            err = "Error: NLLoc output file (%s) does not exist!" % \
                    files['summary']
            print >> sys.stderr, err
            return
        # goto maximum likelihood origin location info line
        try:
            line = lines.pop(0)
            while not line.startswith("HYPOCENTER"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        x = float(line[2])
        y = float(line[4])
        depth = - float(line[6]) # depth: negative down!
        
        lon, lat = gk2lonlat(x, y)
        
        # goto origin time info line
        try:
            line = lines.pop(0)
            while not line.startswith("GEOGRAPHIC  OT"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        year = int(line[2])
        month = int(line[3])
        day = int(line[4])
        hour = int(line[5])
        minute = int(line[6])
        seconds = float(line[7])
        time = UTCDateTime(year, month, day, hour, minute, seconds)

        # goto location quality info line
        try:
            line = lines.pop(0)
            while not line.startswith("QUALITY"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        rms = float(line[8])
        gap = int(line[12])

        # goto location quality info line
        try:
            line = lines.pop(0)
            while not line.startswith("STATISTICS"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        # read in the error ellipsoid representation of the location error.
        # this is given as azimuth/dip/length of axis 1 and 2 and as length
        # of axis 3.
        azim1 = float(line[20])
        dip1 = float(line[22])
        len1 = float(line[24])
        azim2 = float(line[26])
        dip2 = float(line[28])
        len2 = float(line[30])
        len3 = float(line[32])

        errX, errY, errZ = errorEllipsoid2CartesianErrors(azim1, dip1, len1,
                                                          azim2, dip2, len2,
                                                          len3)
        
        # XXX
        # NLLOC uses error ellipsoid for 68% confidence interval relating to
        # one standard deviation in the normal distribution.
        # We multiply all errors by 2 to approximately get the 95% confidence
        # level (two standard deviations)...
        errX *= 2
        errY *= 2
        errZ *= 2

        # determine which model was used:
        # XXX handling of path extremely hackish! to be improved!!
        dirname = os.path.dirname(files['summary'])
        controlfile = os.path.join(dirname, "last.in")
        lines2 = open(controlfile, "rt").readlines()
        line2 = lines2.pop()
        while not line2.startswith("LOCFILES"):
            line2 = lines2.pop()
        line2 = line2.split()
        model = line2[3]
        model = model.split("/")[-1]

        # assign origin info
        self.origin = Origin()
        o = self.origin
        o.method_id = "/".join([ID_ROOT, "location_method", "nlloc", "1"])
        o.origin_uncertainty = OriginUncertainty()
        o.quality = OriginQuality()
        ou = o.origin_uncertainty
        oq = o.quality
        o.longitude = lon
        o.latitude = lat
        o.depth = depth * (-1e3)  # meters positive down!
        if errY > errX:
            ou.azimuth_max_horizontal_uncertainty = 0
        else:
            ou.azimuth_max_horizontal_uncertainty = 90
            ou.min_horizontal_uncertainty, \
                    ou.max_horizontal_uncertainty = \
                    sorted([errX * 1e3, errY * 1e3])
            ou.preferred_description = "uncertainty ellipse"
        o.depth_errors.uncertainty = errZ * 1e3
        oq.standard_error = rms #XXX stimmt diese Zuordnung!!!?!
        oq.azimuthal_gap = gap
        o.depth_type = "from location"
        o.earth_model_id = "%s/earth_model/%s" % (ID_ROOT, model)
        o.time = time
        
        # goto synthetic phases info lines
        try:
            line = lines.pop(0)
            while not line.startswith("PHASE ID"):
                line = lines.pop(0)
        except:
            err = "Error: No correct synthetic phase info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return

        # remove all non phase-info-lines from bottom of list
        try:
            badline = lines.pop()
            while not badline.startswith("END_PHASE"):
                badline = lines.pop()
        except:
            err = "Error: Could not remove unwanted lines at bottom of " + \
                  "NLLoc outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        o.quality.used_phase_count = 0

        # go through all phase info lines
        """
        Order of fields:
        ID Ins Cmp On Pha FM Q Date HrMn Sec Coda Amp Per PriorWt > Err ErrMag
        TTpred Res Weight StaLoc(X Y Z) SDist SAzim RAz RDip RQual Tcorr
        TTerrTcorr
        
        Fields:
        ID (char*6)
            station name or code 
        Ins (char*4)
            instrument identification for the trace for which the time pick corresponds (i.e. SP, BRB, VBB) 
        Cmp (char*4)
            component identification for the trace for which the time pick corresponds (i.e. Z, N, E, H) 
        On (char*1)
            description of P phase arrival onset; i, e 
        Pha (char*6)
            Phase identification (i.e. P, S, PmP) 
        FM (char*1)
            first motion direction of P arrival; c, C, u, U = compression; d, D = dilatation; +, -, Z, N; . or ? = not readable. 
        Date (yyyymmdd) (int*6)
            year (with century), month, day 
        HrMn (hhmm) (int*4)
            Hour, min 
        Sec (float*7.4)
            seconds of phase arrival 
        Err (char*3)
            Error/uncertainty type; GAU 
        ErrMag (expFloat*9.2)
            Error/uncertainty magnitude in seconds 
        Coda (expFloat*9.2)
            coda duration reading 
        Amp (expFloat*9.2)
            Maxumim peak-to-peak amplitude 
        Per (expFloat*9.2)
            Period of amplitude reading 
        PriorWt (expFloat*9.2)
            A-priori phase weight 
        > (char*1)
            Required separator between first part (observations) and second part (calculated values) of phase record. 
        TTpred (float*9.4)
            Predicted travel time 
        Res (float*9.4)
            Residual (observed - predicted arrival time) 
        Weight (float*9.4)
            Phase weight (covariance matrix weight for LOCMETH GAU_ANALYTIC, posterior weight for LOCMETH EDT EDT_OT_WT) 
        StaLoc(X Y Z) (3 * float*9.4)
            Non-GLOBAL: x, y, z location of station in transformed, rectangular coordinates 
            GLOBAL: longitude, latitude, z location of station 
        SDist (float*9.4)
            Maximum likelihood hypocenter to station epicentral distance in kilometers 
        SAzim (float*6.2)
            Maximum likelihood hypocenter to station epicentral azimuth in degrees CW from North 
        RAz (float*5.1)
            Ray take-off azimuth at maximum likelihood hypocenter in degrees CW from North 
        RDip (float*5.1)
            Ray take-off dip at maximum likelihood hypocenter in degrees upwards from vertical down (0 = down, 180 = up) 
        RQual (float*5.1)
            Quality of take-off angle estimation (0 = unreliable, 10 = best) 
        Tcorr (float*9.4)
            Time correction (station delay) used for location
        TTerr (expFloat*9.2)
            Traveltime error used for location 
        """
        for line in lines:
            line = line.split()
            # check which type of phase
            if line[4] == "P":
                type = "P"
            elif line[4] == "S":
                type = "S"
            else:
                continue
            # get values from line
            station = line[0]
            epidist = float(line[22])
            azimuth = float(line[23])
            incident = float(line[24])
            # if we do the location on traveltime-grids without angle-grids we
            # do not get ray azimuth/incidence. but we can at least use the
            # station to hypocenter azimuth which is very close (~2 deg) to the
            # ray azimuth
            if azimuth == 0.0 and incident == 0.0:
                azimuth = float(line[22])
                incident = np.nan
            if line[3] == "I":
                onset = "impulsive"
            elif line[3] == "E":
                onset = "emergent"
            else:
                onset = None
            if line[5] == "U":
                polarity = "positive"
            elif line[5] == "D":
                polarity = "negative"
            else:
                polarity = None
            res = float(line[16])
            weight = float(line[17])

            # assign synthetic phase info
            pick = self.getPick(station=station, phase_hint=type)
            if pick is None:
                msg = "This should not happen! Location output was read and a corresponding pick is missing!"
                warnings.warn(msg)
            arrival = Arrival(origin=o, pick=pick)
            # XXX TODO handling of pick/arrival resource_ids seems unsafe,
            # maybe we should not try to keep nice names and just keep the
            # first random value assigned to a pick/arrival when created
            # (instead of resetting nice ids when outputting the result
            # quakeml)
            #dict['Psynth'] = res + dict['P']
            # residual is defined as P-Psynth by NLLOC and 3dloc!
            arrival.distance = epidist
            arrival.phase = type
            arrival.time_residual = res
            arrival.azimuth = azimuth
            arrival.takeoff_angle = incident
            if onset and not pick.onset:
                pick.onset = onset
            if polarity and not pick.polarity:
                pick.polarity = polarity
            # we use weights 0,1,2,3 but NLLoc outputs floats...
            arrival.time_weight = weight
            o.quality.used_phase_count += 1
        o.used_station_count = len(self.dicts)
        for st in self.streams:
            if not self.getPick(station=st[0].stats.station):
                o.used_station_count -= 1

    def loadHyp2000Data(self):
        files = PROGRAMS['hyp_2000']['files']
        #self.load3dlocSyntheticPhases()
        lines = open(files['summary'], "rt").readlines()
        if lines == []:
            err = "Error: Hypo2000 output file (%s) does not exist!" % \
                    files['summary']
            print >> sys.stderr, err
            return
        # goto origin info line
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" YEAR MO DA  --ORIGIN--"):
                break
        try:
            line = lines.pop(0)
        except:
            err = "Error: No location info found in Hypo2000 outputfile " + \
                  "(%s)!" % files['summary']
            print >> sys.stderr, err
            return

        year = int(line[1:5])
        month = int(line[6:8])
        day = int(line[9:11])
        hour = int(line[13:15])
        minute = int(line[15:17])
        seconds = float(line[18:23])
        time = UTCDateTime(year, month, day, hour, minute, seconds)
        lat_deg = int(line[25:27])
        lat_min = float(line[28:33])
        lat = lat_deg + (lat_min / 60.)
        if line[27] == "S":
            lat = -lat
        lon_deg = int(line[35:38])
        lon_min = float(line[39:44])
        lon = lon_deg + (lon_min / 60.)
        if line[38] == " ":
            lon = -lon
        depth = -float(line[46:51]) # depth: negative down!
        rms = float(line[52:57])
        errXY = float(line[58:63])
        errZ = float(line[64:69])

        # goto next origin info line
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" NSTA NPHS  DMIN MODEL"):
                break
        line = lines.pop(0)

        #model = line[17:22].strip()
        gap = int(line[23:26])

        line = lines.pop(0)
        model = line[49:].strip()

        # assign origin info
        o = self.origin
        o.clear()
        o.method_id = "/".join([ID_ROOT, "location_method", "hyp2000", "1"])
        o.origin_uncertainty = OriginUncertainty()
        o.quality = OriginQuality()
        ou = o.origin_uncertainty
        oq = o.quality
        o.longitude = lon
        o.latitude = lat
        o.depth = depth * (-1e3)  # meters positive down!
        ou.horizontal_uncertainty = errXY
        ou.preferred_description = "horizontal uncertainty"
        o.depth_errors.uncertainty = errZ * 1e3
        oq.quality.standard_error = rms #XXX stimmt diese Zuordnung!!!?!
        oq.quality.azimuthal_gap = gap
        o.depth_type = "from location"
        o.earth_model_id = "%s/earth_model/%s" % (ID_ROOT, model)
        o.time = time
        
        # goto station and phases info lines
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" STA NET COM L CR DIST AZM"):
                break
        
        o.quality.used_phase_count = 0
        #XXX caution: we sometimes access the prior element!
        for i in range(len(lines)):
            # check which type of phase
            if lines[i][32] == "P":
                type = "P"
            elif lines[i][32] == "S":
                type = "S"
            else:
                continue
            # get values from line
            station = lines[i][0:6].strip()
            if station == "":
                station = lines[i-1][0:6].strip()
                azimuth = int(lines[i-1][23:26])
                #XXX check, if incident is correct!!
                incident = int(lines[i-1][27:30])
            else:
                azimuth = int(lines[i][23:26])
                #XXX check, if incident is correct!!
                incident = int(lines[i][27:30])
            if lines[i][31] == "I":
                onset = "impulsive"
            elif lines[i][31] == "E":
                onset = "emergent"
            else:
                onset = None
            if lines[i][33] == "U":
                polarity = "positive"
            elif lines[i][33] == "D":
                polarity = "negative"
            else:
                polarity = None
            res = float(lines[i][61:66])
            weight = float(lines[i][68:72])

            # assign synthetic phase info
            pick = self.getPick(station=station, phase_hint=type)
            if pick is None:
                msg = "This should not happen! Location output was read and a corresponding pick is missing!"
                warnings.warn(msg)
            arrival = Arrival(origin=o, pick=pick)
            # residual is defined as P-Psynth by NLLOC and 3dloc!
            # XXX does this also hold for hyp2000???
            arrival.time_residual = res
            arrival.azimuth = azimuth
            arrival.takeoff_angle = incident
            if onset and not pick.onset:
                pick.onset = onset
            if polarity and not pick.polarity:
                pick.polarity = polarity
            # we use weights 0,1,2,3 but hypo2000 outputs floats...
            arrival.time_weight = weight
            o.quality.used_phase_count += 1
        o.used_station_count = len(self.dicts)
        for dict in self.dicts:
            if dict['P'][1] is None and dict['S'][1] is None:
                o.used_station_count -= 1

    def load3dlocData(self):
        msg = "Not updated after massive QuakeML restructuring."
        raise NotImplementedError(msg)
    
    def updateNetworkMag(self):
        print "updating network magnitude..."
        # XXX TODO magnitude handling
        return
        m = self.magnitude
        m.clear()
        m.method_id = "/".join([ID_ROOT, "magnitude_method", "obspy", "1"])
        m.type = "Ml"
        sms = self.event.station_magnitudes
        sms = []
        amps = self.event.amplitudes
        amps = []
        _i = 0
        _j = 0
        for dict in self.dicts:
            if dict['MagUse'] and 'Mag' in dict:
                _i += 1
                print "%s: %.1f" % (dict['Station'], dict['Mag'])
                sm = StationMagnitude()
                sms.append(sm)
                sm.origin_id = self.origin.resource_id
                sm.mag = dict['Mag']
                sm.resource_id = "/".join((ID_ROOT, "station_magnitude", event_id, _i))
                sm.waveform_id = WaveformStreamID()
                sm.waveform_id.network_code = dict['Network']
                sm.waveform_id.station_code = dict['Station']
                sm.waveform_id.location_code = dict['Location']
                sm.waveform_id.channel_code = dict['MagChannel']
                for num in [1, 2]:
                    pgvkey = "PGV%i" % num
                    if pgvkey in dict:
                        _j += 1
                        amp = Amplitude()
                        amps.append(amp)
                        amp.resource_id = "/".join((ID_ROOT, "amplitude", event_id, _j))
                        amp.generic_amplitude = dict[pgvkey]
                        amp.unit = "m/s"
                        amp.waveform_id = WaveformStreamID()
                        amp.waveform_id.network_code = dict['Network']
                        amp.waveform_id.station_code = dict['Station']
                        amp.waveform_id.location_code = dict['Location']
                        amp.waveform_id.channel_code = dict["PGV%iCHA" % num]
                        t1 = dict['MagMin%sT' % num]
                        t2 = dict['MagMax%sT' % num]
                        t1, t2 = sorted([t1, t2])
                        tw = TimeWindow()
                        amp.time_window = tw
                        tw.reference = self.time_rel2abs(t1)
                        tw.begin = 0
                        tw.end = t2 - t1
                        comment = "PGV. Reference is time of first pick of peak-to-peak picking for magnitude estimation. End gives relative time of second pick. Value is absolute maximum of both picks corrected to Wood-Anderson."
                        amp.comments.append(Comment(comment))

        m.station_count = len(m.station_magnitude_contributions)
        weight = None
        if m.station_count:
            weight = 1.0 / m.station_count
        for _i, sm in enumerate(sms):
            contrib = StationMagnitudeContribution()
            if weight is not None:
                contrib.weight = weight
            contrib.station_magnitude_id = sm.resource_id
            m.station_magnitude_contributions.append(contrib)

        if m.station_count == 0:
            m.clear()
            sms = []
        else:
            m.mag = np.mean([_m.mag for _m in sms])
            m.mag_errors = np.var([_m.mag for _m in sms])
        print "new network magnitude: %.2f (Variance: %.2f)" % \
                (m.mag, m.mag_errors)
        self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % (m.mag, m.mag_errors)
        if hasattr(self, 'netMagText'):
            self.netMagText.set_text(self.netMagLabel)
    
    # XXX TODO Hypo distances needed?? where??
    def calculateEpiHypoDists(self):
        o = self.origin
        if not o.longitude or not o.latitude:
            err = "Error: No coordinates for origin!"
            print >> sys.stderr, err
        # XXX TODO need to check that distances are stored with arrival upon
        # creation
        epidists = [a.distance for a in o.arrivals]
        # XXX TODO check if dict['distHypo'] is needed anywhere
        if not o.quality:
            o.quality = OriginQuality()
        o.quality.maximum_distance = max(epidists)
        o.quality.minimum_distance = min(epidists)
        o.quality.median_distance = np.median(epidists)

    def hypoDist(self, coords):
        o = self.origin
        epi_dist, _, _ = gps2DistAzimuth(o.latitude, o.longitude,
                                         coords['latitude'],
                                         coords['longitude'])
        # origin depth is in m positive down, station elevation is in m
        # positive up
        z_dist = o.depth + coords['elevation']
        return np.sqrt(epi_dist ** 2 + z_dist ** 2) / 1e3

    def calculateStationMagnitudes(self):
        o = self.origin
        self.stationmagnitudes = []
        for st, dict in zip(self.streams, self.dicts):
            amplitudes = []
            timedeltas = []
            pazs = []
            channels = []
            for tr in st:
                amp = self.getAmplitude(seed_string=tr.id)
                if not amp:
                    continue
                amplitudes.append(amp)
                pazs.append(tr.stats.paz)
                td = amp.time_window.begin + amp.time_window.end
                timedeltas.append(td)
                channels.append(tr.stats.channel)
            
            if not amplitudes:
                continue

            # XXX hyp_dist doesnt exist anymore
            dist = self.hypoDist(tr.stats.coordinates)
            mag = estimateMagnitude(pazs,
                                    [a.generic_amplitude for a in amplitudes],
                                    timedeltas, dist)
            sm = StationMagnitude()
            self.stationmagnitudes.append(sm)
            sm.origin_id = o.resource_id
            sm.mag = mag
            sm.type = "ML"
            sm.method_id = "/".join([ID_ROOT, "station_magnitude_method", "obspy", "1"])
            sm.waveform_id = WaveformStreamID()
            stats = st[0].stats
            sm.waveform_id.network_code = stats.network
            sm.waveform_id.station_code = stats.station
            sm.waveform_id.location_code = stats.location
            print 'calculated new magnitude for %s: %0.2f (channels: %s)' \
                  % (stats.station, mag, channels)
            raise Exception("setting station magnitudes not yet implemented")
            # XXX create new stationmagnitude
    
    #see http://www.scipy.org/Cookbook/LinearRegression for alternative routine
    #XXX replace with drawWadati()
    def drawWadati(self):
        """
        Shows a Wadati diagram plotting P time in (truncated) Julian seconds
        against S-P time for every station and doing a linear regression
        using rpy. An estimate of Vp/Vs is given by the slope + 1.
        """
        try:
            import rpy
        except:
            err = "Error: Package rpy could not be imported!\n" + \
                  "(We should switch to scipy polyfit, anyway!)"
            print >> sys.stderr, err
            return
        pTimes = []
        spTimes = []
        stations = []
        for st, dict in zip(self.streams, self.dicts):
            net = st[0].stats.network
            sta = st[0].stats.station
            pick_p = self.getPick(network=net, station=sta, phase_hint='P')
            pick_s = self.getPick(network=net, station=sta, phase_hint='S')
            if pick_p and pick_s:
                p = pick_p.time
                p = "%.3f" % p.timestamp
                p = float(p[-7:])
                pTimes.append(p)
                sp = pick_s.time - pick_p.time
                spTimes.append(sp)
                stations.append(dict['Station'])
            else:
                continue
        if len(pTimes) < 2:
            err = "Error: Less than 2 P-S Pairs!"
            print >> sys.stderr, err
            return
        my_lsfit = rpy.r.lsfit(pTimes, spTimes)
        gradient = my_lsfit['coefficients']['X']
        intercept = my_lsfit['coefficients']['Intercept']
        vpvs = gradient + 1.
        ressqrsum = 0.
        for res in my_lsfit['residuals']:
            ressqrsum += (res ** 2)
        y0 = 0.
        x0 = - (intercept / gradient)
        x1 = max(pTimes)
        y1 = (gradient * float(x1)) + intercept

        fig = self.fig
        self.axWadati = fig.add_subplot(111)
        self.fig.subplots_adjust(bottom=0.07, top=0.95, left=0.07, right=0.98)
        ax = self.axWadati
        ax = fig.add_subplot(111)

        ax.scatter(pTimes, spTimes)
        for i, station in enumerate(stations):
            ax.text(pTimes[i], spTimes[i], station, va = "top")
        ax.plot([x0, x1], [y0, y1])
        ax.axhline(0, color="blue", ls=":")
        # origin time estimated by wadati plot
        ax.axvline(x0, color="blue", ls=":",
                   label="origin time from wadati diagram")
        # origin time from event location
        if self.origin.time:
            otime = "%.3f" % self.origin.time.timestamp
            otime = float(otime[-7:])
            ax.axvline(otime, color="red", ls=":",
                       label="origin time from event location")
        ax.text(0.1, 0.7, "Vp/Vs: %.2f\nSum of squared residuals: %.3f" % \
                (vpvs, ressqrsum), transform=ax.transAxes)
        ax.text(0.1, 0.1, "Origin time from event location", color="red",
                transform=ax.transAxes)
        #ax.axis("auto")
        ax.set_xlim(min(x0 - 1, otime - 1), max(pTimes) + 1)
        ax.set_ylim(-1, max(spTimes) + 1)
        ax.set_xlabel("absolute P times (julian seconds, truncated)")
        ax.set_ylabel("P-S times (seconds)")
        ax.set_title("Wadati Diagram")
        self.canv.draw()

    def delWadati(self):
        if hasattr(self, "axWadati"):
            self.fig.delaxes(self.axWadati)
            del self.axWadati

    def drawStreamOverview(self):
        stNum = len(self.streams)
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        for i, st in enumerate(self.streams):
            tr = st.select(component="Z")[0]
            # make sure that the relative x-axis times start with 0 at the time
            # specified as start time on command line
            starttime_relative = self.time_abs2rel(tr.stats.starttime)
            sampletimes = np.arange(starttime_relative,
                    starttime_relative + (tr.stats.delta * tr.stats.npts),
                    tr.stats.delta)
            # sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            if i == 0:
                ax = fig.add_subplot(stNum, 1, i+1)
            else:
                ax = fig.add_subplot(stNum, 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData, ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            # we have to rotate first, because we have to copy the whole stream..
            # ZRT rotation is not regarded because it doesn't change the Z component..
            if self.widgets.qToolButton_rotateLQT.isChecked():
                d = self.dicts[i]
                tmp_st = self.streams[i].copy()
                self._rotateLQT(tmp_st, self.origin)
                tr = tmp_st.select(component="Z")[0]
            else:
                tr = tr.copy()
            # rotation needs to be done first!
            if self.widgets.qToolButton_filter.isChecked():
                self._filter(tr)
            if self.widgets.qToolButton_trigger.isChecked():
                self._trigger(tr)
            # normalize with overall sensitivity and convert to nm/s
            # if not explicitly deactivated on command line
            if not self.options.nonormalization and not self.options.nometadata:
                # special handling for GSE2 data: apply calibration
                calib = 1.0
                if tr.stats._format == "GSE2":
                    calib = tr.stats.calib * 2 * np.pi / tr.stats.gse2.calper
                plts.append(ax.plot(sampletimes, tr.data * 1e9 / tr.stats.paz.sensitivity / calib, color='k', zorder=1000)[0])
            else:
                plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
        self.drawIds()
        axs[-1].xaxis.set_ticks_position("both")
        label = self.T0.isoformat().replace("T", "  ")
        self.supTit = fig.suptitle(label, ha="left", va="bottom",
                                   x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)

    def drawEventMap(self):
        m = self.magnitude
        o = self.origin
        if not o:
            err = "Error: No hypocenter data!"
            print >> sys.stderr, err
            return
        #XXX self.figEventMap.canvas.widgetlock.release(toolbar)
        #self.axEventMap = self.fig.add_subplot(111)
        bbox = matplotlib.transforms.Bbox.from_extents(0.08, 0.08, 0.92, 0.92)
        self.axEventMap = self.fig.add_axes(bbox, aspect='equal', adjustable='datalim')
        axEM = self.axEventMap
        #axEM.set_aspect('equal', adjustable="datalim")
        #self.fig.subplots_adjust(bottom=0.07, top=0.95, left=0.07, right=0.98)
        axEM.scatter([o.longitude], [o.latitude], 30, color='red', marker='o')
        print o.origin_uncertainty.min_horizontal_uncertainty, o.origin_uncertainty.max_horizontal_uncertainty
        # XXX TODO handle different origin uncertainty descriptions
        #errLon, errLat = utlLonLat(o.longitude, o.latitude, o.longitude_errors,
        #                           o.latitude_errors)
        # XXX TODO handle horizontal errors correctly
        errLon, errLat = utlLonLat(o.longitude, o.latitude,
            o.origin_uncertainty.min_horizontal_uncertainty / 1e3,
            o.origin_uncertainty.max_horizontal_uncertainty / 1e3)
        errLon -= o.longitude
        errLat -= o.latitude
        ypos = 0.97
        xpos = 0.03
        info = str(o).replace("\t", " ")
        axEM.text(xpos, ypos, info, va='top', ha='left', family='monospace',
                  transform=axEM.transAxes)
        #if o.quality and o.quality.standard_error:
        #    axEM.text(xpos, ypos, "\n\n\n\n Residual: %.3f s" % \
        #              o.quality.standard_error, va='top', ha='left',
        #              color=PHASE_COLORS['P'], transform=axEM.transAxes,
        #              family='monospace')
        if m.mag and m.mag_errors:
            self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % \
                               (m.mag, m.mag_errors)
            self.netMagText = axEM.text(xpos, ypos, self.netMagLabel, va='top',
                    ha='left', transform=axEM.transAxes,
                    color=PHASE_COLORS['Mag'], family='monospace')
        ou = o.origin_uncertainty
        if ou:
            if ou.preferred_description == "uncertainty ellipse":
                print >> sys.stderr, "Lon/Lat scaling of plotted ellipse might be wrong."
                errorell = Ellipse(xy=[o.longitude, o.latitude],
                                   width=errLon,
                                   height=errLat,
                                   angle=ou.azimuth_max_horizontal_uncertainty,
                                   fill=False)
                axEM.add_artist(errorell)
        self.scatterMagIndices = []
        self.scatterMagLon = []
        self.scatterMagLat = []
        for i, (st, dict) in enumerate(zip(self.streams, self.dicts)):
            # determine which stations are used in location, set color
            net = st[0].stats.network
            sta = st[0].stats.station
            pick_p = self.getPick(network=net, station=sta, phase_hint='P')
            pick_s = self.getPick(network=net, station=sta, phase_hint='S')
            arrival_p = getArrivalForPick(self.event, pick_p)
            arrival_s = getArrivalForPick(self.event, pick_s)
            if (arrival_p and arrival_p.time_residual) or (arrival_s and arrival_s.time_residual):
                stationColor = 'black'
            else:
                stationColor = 'gray'
            # plot stations at respective coordinates with names
            axEM.scatter((dict['StaLon'],), (dict['StaLat'],), s=300,
                         marker='v', color='', edgecolor=stationColor)
            axEM.text(dict['StaLon'], dict['StaLat'], '  ' + dict['Station'],
                      color=stationColor, va='top', family='monospace')
            for _i, (pick, arrival) in enumerate([[pick_p, arrival_p], [pick_s, arrival_s]]):
                if arrival.time_residual:
                    res_info = '\n' * (_i + 2) + '%+0.3fs' % arrival.time_residual
                    if pick.polarity:
                        res_info += '  %s' % pick.polarity
                    axEM.text(dict['StaLon'], dict['StaLat'], res_info,
                              va='top', family='monospace',
                              color=PHASE_COLORS[pick.phase_hint])
            for sm in self.event.station_magnitudes:
                if sm.waveform_id.station_code != dict['Station']:
                    continue
                self.scatterMagIndices.append(i)
                self.scatterMagLon.append(dict['StaLon'])
                self.scatterMagLat.append(dict['StaLat'])
                label = '\n' * (_i + 3) + \
                        '  %0.2f (%s)' % (sm.mag, sm.waveform_id.channel_code)
                axEM.text(dict['StaLon'], dict['StaLat'], label, va='top',
                          family='monospace', color=PHASE_COLORS['Mag'])
                break
        if len(self.scatterMagLon) > 0:
            self.scatterMag = axEM.scatter(self.scatterMagLon,
                    self.scatterMagLat, s=150, marker='v', color='',
                    edgecolor='black', picker=10)
                
        axEM.set_xlabel('Longitude')
        axEM.set_ylabel('Latitude')
        time = o.time
        timestr = time.strftime("%Y-%m-%d  %H:%M:%S")
        timestr += ".%02d" % (time.microsecond / 1e4 + 0.5)
        axEM.set_title(timestr)
        #####XXX disabled because it plots the wrong info if the event was
        ##### fetched from seishub
        #####lines = open(PROGRAMS['3dloc']['files']['out']).readlines()
        #####infoEvent = lines[0].rstrip()
        #####infoPicks = ''
        #####for line in lines[1:]:
        #####    infoPicks += line
        #####axEM.text(0.02, 0.95, infoEvent, transform = axEM.transAxes,
        #####                  fontsize = 12, verticalalignment = 'top',
        #####                  family = 'monospace')
        #####axEM.text(0.02, 0.90, infoPicks, transform = axEM.transAxes,
        #####                  fontsize = 10, verticalalignment = 'top',
        #####                  family = 'monospace')
        # save id to disconnect when switching back to stream dislay
        self.eventMapPickEvent = self.canv.mpl_connect('pick_event',
                                                       self.selectMagnitudes)
        try:
            self.scatterMag.set_facecolors(self.eventMapColors)
        except:
            pass

        # make hexbin scatter plot, if located with NLLoc
        # XXX no vital commands should come after this block, as we do not
        # handle exceptions!
        if "NLLOC" in str(o.method_id).upper() and os.path.isfile(PROGRAMS['nlloc']['files']['scatter']):
            cmap = matplotlib.cm.gist_heat_r
            data = readNLLocScatter(PROGRAMS['nlloc']['files']['scatter'],
                                    self.widgets.qPlainTextEdit_stderr)
            axEM.hexbin(data[0], data[1], cmap=cmap, zorder=-1000)

            self.axEventMapInletXY = self.fig.add_axes([0.8, 0.8, 0.16, 0.16])
            axEMiXY = self.axEventMapInletXY
            self.axEventMapInletXZ = self.fig.add_axes([0.8, 0.73, 0.16, 0.06],
                    sharex=axEMiXY)
            self.axEventMapInletZY = self.fig.add_axes([0.73, 0.8, 0.06, 0.16],
                    sharey=axEMiXY)
            axEMiXZ = self.axEventMapInletXZ
            axEMiZY = self.axEventMapInletZY
            
            # z axis in km
            axEMiXY.hexbin(data[0], data[1], cmap=cmap)
            axEMiXZ.hexbin(data[0], data[2], cmap=cmap)
            axEMiZY.hexbin(data[2], data[1], cmap=cmap)
            stalons = [d['StaLon'] for d in self.dicts]
            stalats = [d['StaLat'] for d in self.dicts]
            stadepths = [d['StaEle'] / 1e3 for d in self.dicts]
            axEMiXY.scatter(stalons, stalats, s=200, marker='v', color='k')
            axEMiXZ.scatter(stalons, stadepths, s=200, marker='v', color='k')
            axEMiZY.scatter(stadepths, stalats, s=200, marker='v', color='k')

            min_x = min(data[0])
            max_x = max(data[0])
            min_y = min(data[1])
            max_y = max(data[1])
            min_z = min(data[2])
            max_z = max(data[2])
            axEMiZY.set_xlim(min_z, max_z)
            axEMiXZ.set_ylim(min_z, max_z)
            axEMiXY.set_xlim(min_x, max_x)
            axEMiXY.set_ylim(min_y, max_y)
            axEMiXZ.invert_yaxis()
            axEMiZY.invert_xaxis()
            
            formatter = FormatStrFormatter("%.3f")
            axEMiXY.xaxis.set_major_formatter(formatter)
            axEMiXY.yaxis.set_major_formatter(formatter)
            
            # only draw very few ticklabels in our tiny subaxes
            for ax in [axEMiXZ.xaxis, axEMiXZ.yaxis,
                       axEMiZY.xaxis, axEMiZY.yaxis]:
                ax.set_major_locator(MaxNLocator(nbins=3))
            
            # hide ticklabels on XY plot
            for ax in [axEMiXY.xaxis, axEMiXY.yaxis]:
                plt.setp(ax.get_ticklabels(), visible=False)


    def delEventMap(self):
        try:
            self.canv.mpl_disconnect(self.eventMapPickEvent)
        except AttributeError:
            pass
        if hasattr(self, "axEventMapInletXY"):
            self.fig.delaxes(self.axEventMapInletXY)
            del self.axEventMapInletXY
        if hasattr(self, "axEventMapInletXZ"):
            self.fig.delaxes(self.axEventMapInletXZ)
            del self.axEventMapInletXZ
        if hasattr(self, "axEventMapInletZY"):
            self.fig.delaxes(self.axEventMapInletZY)
            del self.axEventMapInletZY
        if hasattr(self, "axEventMap"):
            self.fig.delaxes(self.axEventMap)
            del self.axEventMap

    def selectMagnitudes(self, event):
        if not self.widgets.qToolButton_showMap.isChecked():
            return
        if event.artist != self.scatterMag:
            return
        i = self.scatterMagIndices[event.ind[0]]
        j = event.ind[0]
        dict = self.dicts[i]
        dict['MagUse'] = not dict['MagUse']
        if dict['MagUse']:
            self.eventMapColors[j] = (0.,  1.,  0.,  1.)
        else:
            self.eventMapColors[j] = (0.,  0.,  0.,  0.)
        self.scatterMag.set_facecolors(self.eventMapColors)
        self.updateNetworkMag()
        self.canv.draw()
    
    def dicts2hypo71Stations(self):
        """
        Returns the station location information in self.dicts in hypo71
        stations file format as a string. This string can then be written to
        a file.
        """
        fmt = "%6s%02i%05.2fN%03i%05.2fE%4i\n"
        hypo71_string = ""

        for dict in self.dicts:
            sta = dict['Station']
            lon = dict['StaLon']
            lon_deg = int(lon)
            lon_min = (lon - lon_deg) * 60.
            lat = dict['StaLat']
            lat_deg = int(lat)
            lat_min = (lat - lat_deg) * 60.
            # hypo 71 format uses elevation in meters not kilometers
            ele = dict['StaEle'] * 1000
            hypo71_string += fmt % (sta, lat_deg, lat_min, lon_deg, lon_min,
                                    ele)

        return hypo71_string

    # XXX continue here!!!
    
    def dicts2hypo71Phases(self):
        """
        Returns the pick information in self.dicts in hypo71 phase file format
        as a string. This string can then be written to a file.

        Information on the file formats can be found at:
        http://geopubs.wr.usgs.gov/open-file/of02-171/of02-171.pdf p.30

        Quote:
        The traditional USGS phase data input format (not Y2000 compatible)
        Some fields were added after the original HYPO71 phase format
        definition.
        
        Col. Len. Format Data
         1    4  A4       4-letter station site code. Also see col 78.
         5    2  A2       P remark such as "IP". If blank, any P time is
                          ignored.
         7    1  A1       P first motion such as U, D, +, -, C, D.
         8    1  I1       Assigned P weight code.
         9    1  A1       Optional 1-letter station component.
        10   10  5I2      Year, month, day, hour and minute.
        20    5  F5.2     Second of P arrival.
        25    1  1X       Presently unused.
        26    6  6X       Reserved remark field. This field is not copied to
                          output files.
        32    5  F5.2     Second of S arrival. The S time will be used if this
                          field is nonblank.
        37    2  A2, 1X   S remark such as "ES".
        40    1  I1       Assigned weight code for S.
        41    1  A1, 3X   Data source code. This is copied to the archive
                          output.
        45    3  F3.0     Peak-to-peak amplitude in mm on Develocorder viewer
                          screen or paper record.
        48    3  F3.2     Optional period in seconds of amplitude read on the
                          seismogram. If blank, use the standard period from
                          station file.
        51    1  I1       Amplitude magnitude weight code. Same codes as P & S.
        52    3  3X       Amplitude magnitude remark (presently unused).
        55    4  I4       Optional event sequence or ID number. This number may
                          be replaced by an ID number on the terminator line.
        59    4  F4.1     Optional calibration factor to use for amplitude
                          magnitudes. If blank, the standard cal factor from
                          the station file is used.
        63    3  A3       Optional event remark. Certain event remarks are
                          translated into 1-letter codes to save in output.
        66    5  F5.2     Clock correction to be added to both P and S times.
        71    1  A1       Station seismogram remark. Unused except as a label
                          on output.
        72    4  F4.0     Coda duration in seconds.
        76    1  I1       Duration magnitude weight code. Same codes as P & S.
        77    1  1X       Reserved.
        78    1  A1       Optional 5th letter of station site code.
        79    3  A3       Station component code.
        82    2  A2       Station network code.
        84-85 2  A2     2-letter station location code (component extension).
        """

        fmtP = "%4s%1sP%1s%1i %15s"
        fmtS = "%12s%1sS%1s%1i\n"
        hypo71_string = ""

        for st, dict in zip(self.streams, self.dicts):
            net = st[0].stats.network
            sta = st[0].stats.station
            pick_p = self.getPick(network=net, station=sta, phase_hint='P')
            pick_s = self.getPick(network=net, station=sta, phase_hint='S')
            if not pick_p and not pick_s:
                continue

            # P Pick
            pick = pick_p
            t = pick.time
            hundredth = int(round(t.microsecond / 1e4))
            if hundredth == 100:  # XXX check!!
                t_p = t + 1
                hundredth = 0
            else:
                t_p = t
            date = t_p.strftime("%y%m%d%H%M%S") + ".%02d" % hundredth
            if pick.onset == 'impulsive':
                onset = 'I'
            elif pick.onset == 'emergent':
                onset = 'E'
            else:
                onset = '?'
            if pick.polarity == "positive":
                polarity = "U"
            elif pick.polarity == "negative":
                polarity = "D"
            else:
                polarity = "?"
            try:
                weight = int(pick.extra.weight)
            except:
                weight = 0
            hypo71_string += fmtP % (sta, onset, polarity, weight, date)

            # S Pick
            if pick_s:
                if not pick_p:
                    err = "Warning: Trying to print a Hypo2000 phase file " + \
                          "with an S phase without P phase.\n" + \
                          "This case might not be covered correctly and " + \
                          "could screw our file up!"
                    print >> sys.stderr, err
                pick = pick_s
                t2 = pick.time
                # if the S time's absolute minute is higher than that of the
                # P pick, we have to add 60 to the S second count for the
                # hypo 2000 output file
                # +60 %60 is necessary if t.min = 57, t2.min = 2 e.g.
                mindiff = (t2.minute - t.minute + 60) % 60
                abs_sec = t2.second + (mindiff * 60)
                if abs_sec > 99:
                    err = "Warning: S phase seconds are greater than 99 " + \
                          "which is not covered by the hypo phase file " + \
                          "format! Omitting S phase of station %s!" % sta
                    print >> sys.stderr, err
                    hypo71_string += "\n"
                    continue
                hundredth = int(round(t2.microsecond / 1e4))
                if hundredth == 100:
                    abs_sec += 1
                    hundredth = 0
                date2 = "%s.%02d" % (abs_sec, hundredth)
                if pick.onset == 'impulsive':
                    onset2 = 'I'
                elif pick.onset == 'emergent':
                    onset2 = 'E'
                else:
                    onset2 = '?'
                if pick.polarity == "positive":
                    polarity2 = "U"
                elif pick.polarity == "negative":
                    polarity2 = "D"
                else:
                    polarity2 = "?"
                try:
                    weight2 = int(pick.extra.weight)
                except:
                    weight2 = 0
                hypo71_string += fmtS % (date2, onset2, polarity2, weight2)
            else:
                hypo71_string += "\n"

        return hypo71_string
    
    def dicts2NLLocPhases(self):
        """
        Returns the pick information in self.dicts in NonLinLoc's own phase
        file format as a string. This string can then be written to a file.
        Currently only those fields really needed in location are actually used
        in assembling the phase information string.

        Information on the file formats can be found at:
        http://alomax.free.fr/nlloc/soft6.00/formats.html#_phase_

        Quote:
        NonLinLoc Phase file format (ASCII, NLLoc obsFileType = NLLOC_OBS)
        
        The NonLinLoc Phase file format is intended to give a comprehensive
        phase time-pick description that is easy to write and read.
        
        For each event to be located, this file contains one set of records. In
        each set there is one "arrival-time" record for each phase at each seismic
        station. The final record of each set is a blank. As many events as desired can
        be included in one file.
        
        Each record has a fixed format, with a blank space between fields. A
        field should never be left blank - use a "?" for unused characther fields and a
        zero or invalid numeric value for numeric fields.
        
        The NonLinLoc Phase file record is identical to the first part of each
        phase record in the NLLoc Hypocenter-Phase file output by the program NLLoc.
        Thus the phase list output by NLLoc can be used without modification as time
        pick observations for other runs of NLLoc.
        
        NonLinLoc phase record:
        Fields:
        Station name (char*6)
            station name or code 
        Instrument (char*4)
            instument identification for the trace for which the time pick
            corresponds (i.e. SP, BRB, VBB) 
        Component (char*4)
            component identification for the trace for which the time pick
            corresponds (i.e. Z, N, E, H) 
        P phase onset (char*1)
            description of P phase arrival onset; i, e 
        Phase descriptor (char*6)
            Phase identification (i.e. P, S, PmP) 
        First Motion (char*1)
            first motion direction of P arrival; c, C, u, U = compression;
            d, D = dilatation; +, -, Z, N; . or ? = not readable. 
        Date (yyyymmdd) (int*6)
            year (with century), month, day 
        Hour/minute (hhmm) (int*4)
            Hour, min 
        Seconds (float*7.4)
            seconds of phase arrival 
        Err (char*3)
            Error/uncertainty type; GAU 
        ErrMag (expFloat*9.2)
            Error/uncertainty magnitude in seconds 
        Coda duration (expFloat*9.2)
            coda duration reading 
        Amplitude (expFloat*9.2)
            Maxumim peak-to-peak amplitude 
        Period (expFloat*9.2)
            Period of amplitude reading 
        PriorWt (expFloat*9.2)
        
        A-priori phase weight Currently can be 0 (do not use reading) or
        1 (use reading). (NLL_FORMAT_VER_2 - WARNING: under development)
        
        Example:
        
        GRX    ?    ?    ? P      U 19940217 2216   44.9200 GAU  2.00e-02 -1.00e+00 -1.00e+00 -1.00e+00
        GRX    ?    ?    ? S      ? 19940217 2216   48.6900 GAU  4.00e-02 -1.00e+00 -1.00e+00 -1.00e+00
        CAD    ?    ?    ? P      D 19940217 2216   46.3500 GAU  2.00e-02 -1.00e+00 -1.00e+00 -1.00e+00
        CAD    ?    ?    ? S      ? 19940217 2216   50.4000 GAU  4.00e-02 -1.00e+00 -1.00e+00 -1.00e+00
        BMT    ?    ?    ? P      U 19940217 2216   47.3500 GAU  2.00e-02 -1.00e+00 -1.00e+00 -1.00e+00
        """
        nlloc_str = ""

        for pick in self.picks:
            sta = pick.waveform_id.station_code.ljust(6)
            inst = "?".ljust(4)
            comp = "?".ljust(4)
            onset = "?"
            pha = pick.phase_hint.ljust(6)
            pol = "?"
            t = pick.time
            date = t.strftime("%Y%m%d")
            hour_min = t.strftime("%H%M")
            sec = "%7.4f" % (t.second + t.microsecond / 1e6)
            error_type = "GAU"
            error = None
            # XXX check: should we take only half of the complete left-to-right error?!?
            if pick.time_errors.upper_uncertainty and pick.time_errors.lower_uncertainty:
                error = pick.time_errors.upper_uncertainty + pick.time_errors.lower_uncertainty
            elif pick.time_errors.uncertainty:
                error = 2 * pick.time_errors.uncertainty
            if error is None:
                err = "Warning: Missing pick error. " + \
                      "Discarding %s phase of station %s."
                err = err % (phase, sta)
                print >> sys.stderr, err
                continue
            error = "%9.2e" % error
            coda_dur = "-1.00e+00"
            ampl = "-1.00e+00"
            period = "-1.00e+00"
            fields = [sta, inst, comp, onset, pha, pol, date, hour_min,
                      sec, error_type, error, coda_dur, ampl, period]
            phase_str = " ".join(fields)
            nlloc_str += phase_str + "\n"
        return nlloc_str

    def dicts2XML(self):
        """
        Returns information of all dictionaries as xml file (type string)
        """
        e = self.event
        o = self.origin
        event_id = str(e.resource_id).split("/")[-2] #XXX id of the file
        # if the sysop checkbox is checked, we set the account in the xml
        # to sysop (and also use sysop as the seishub user)
        if self.widgets.qCheckBox_sysop.isChecked():
            author = "sysop"
        else:
            author = self.server['User']
        e.creation_info = CreationInfo()
        e.creation_info.author = author
        e.creation_info.agency_id = "Erdbebendienst Bayern"
        e.creation_info.agency_uri = "%s/agency" % ID_ROOT

        e.extra = AttribDict()
        e.extra.evaluationMode = {'value': "manual", '_namespace': NAMESPACE}
        e.extra.public = {'value': self.widgets.qCheckBox_publishEvent.isChecked(),
                          '_namespace': NAMESPACE}

        # check if an quakeML event type should be set
        event_quakeml_type = str(self.widgets.qComboBox_eventType.currentText())
        if event_quakeml_type != '<event type>':
            e.event_type = event_quakeml_type
        
        # XXX standard values for unset keys!!!???!!!???
        epidists = []
        # go through all stream-dictionaries and look for picks
        _i = 0
        e.picks[:] = []
        # XXX TODO change handling of resource ids. never change id set at
        # creation and make sure that only wanted arrivals/picks get
        # saved/stored.
        for pick in self.picks:
            arrival = getArrivalForPick(self.event, pick)
            pick.resource_id = "/".join((ID_ROOT, "pick", event_id, str(_i)))
            e.picks.append(pick)
            if arrival:
                arrival.resource_id = "/".join((ID_ROOT, "arrival", event_id, str(_i)))
                arrival.pick_id = pick.resource_id
            _i += 1

        #origin output
        if self.origin:
            e.origins = [self.origin]
        
        #magnitude output
        if self.magnitude:
            e.magnitudes = [self.magnitude]
        
        #focal mechanism output
        if self.focalMechanism:
            e.focal_mechanisms = [self.focalMechanism]

        cat = Catalog(events=[e])
        with NamedTemporaryFile() as tf:
            tmp = tf.name
            cat.write(tmp, "QUAKEML")
            with open(tmp) as fh:
                xml = fh.read()

        return xml
    
    def setXMLEventID(self, event_id=None):
        #XXX is problematic if two people make a location at the same second!
        # then one event is overwritten with the other during submission.
        if event_id is None:
            event_id = UTCDateTime().strftime('%Y%m%d%H%M%S') 
        self.event.resource_id = "/".join([ID_ROOT, "event", event_id, "1"])

    def uploadSeisHub(self):
        """
        Upload xml file to SeisHub
        """
        # check, if the event should be uploaded as sysop. in this case we use
        # the sysop client instance for the upload (and also set
        # user_account in the xml to "sysop").
        # the correctness of the sysop password is tested when checking the
        # sysop box and entering the password immediately.
        if self.widgets.qCheckBox_sysop.isChecked():
            userid = "sysop"
            client = self.clients['SeisHub-sysop']
        else:
            userid = self.server['User']
            client = self.clients['SeisHub']

        # if we did no location at all, and only picks would be saved the
        # EventID ist still not set, so we have to do this now.
        if not self.event.get("resource_id"):
            err = "Error: Event resource_id not set."
            print >> sys.stderr, err
            return
            #self.setXMLEventID()
        name = str(self.event.resource_id).split("/")[-2] #XXX id of the file
        # create XML and also save in temporary directory for inspection purposes
        print "creating xml..."
        data = self.dicts2XML()
        filename = name
        if not filename.endswith(".xml"):
            filename += ".xml"
        tmpfile = os.path.join(self.tmp_dir, filename)
        tmpfile2 = os.path.join(tempfile.gettempdir(), filename)
        msg = "writing xml as %s and %s (for debugging purposes and in " + \
              "case of upload errors)"
        print msg % (tmpfile, tmpfile2)
        for fname in [tmpfile, tmpfile2]:
            open(fname, "wt").write(data)

        headers = {}
        try:
            host = socket.gethostname()
        except:
            host = "localhost"
        headers["Host"] = host
        headers["User-Agent"] = "obspyck"
        headers["Content-type"] = "text/xml; charset=\"UTF-8\""
        headers["Content-length"] = "%d" % len(data)
        code, message = client.event.putResource(name, xml_string=data,
                                                 headers=headers)
        msg = "Account: %s" % userid
        msg += "\nUser: %s" % self.username
        msg += "\nName: %s" % name
        msg += "\nServer: %s" % self.server['Server']
        msg += "\nResponse: %s %s" % (code, message)
        print msg

    def deleteEventInSeisHub(self, resource_name):
        """
        Delete xml file from SeisHub.
        (Move to SeisHubs trash folder if this option is activated)
        """
        # check, if the event should be deleted as sysop. in this case we
        # use the sysop client instance for the DELETE request.
        # sysop may delete resources from any user.
        # at the moment deleted resources go to SeisHubs trash folder (and can
        # easily be resubmitted using the http interface).
        # the correctness of the sysop password is tested when checking the
        # sysop box and entering the password immediately.
        if self.widgets.qCheckBox_sysop.isChecked():
            userid = "sysop"
            client = self.clients['SeisHub-sysop']
        else:
            userid = self.server['User']
            client = self.clients['SeisHub']
        
        headers = {}
        try:
            host = socket.gethostname()
        except:
            host = "localhost"
        headers["Host"] = host
        headers["User-Agent"] = "obspyck"
        code, message = client.event.deleteResource(str(resource_name),
                                                    headers=headers)
        msg = "Deleting Event!"
        msg += "\nAccount: %s" % userid
        msg += "\nUser: %s" % self.username
        msg += "\nName: %s" % resource_name
        msg += "\nServer: %s" % self.server['Server']
        msg += "\nResponse: %s %s" % (code, message)
        print msg
    
    def clearDictionaries(self):
        print "Clearing previous data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle',
                       'pazZ', 'pazN', 'pazE']
        for dict in self.dicts:
            for key in dict.keys():
                if not key in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        # XXX delegate all resetting to methods like self.clearOriginMagnitudeDictionaries() !!!
        # XXX but caution this can easily change behavior of obspyck!!
        self.origin.clear()
        self.magnitude.clear()
        self.clearFocmecDictionary()
        self.event.clear()
        self.picks = []
        self.arrivals = []
        self.amplitudes = []

    def clearOriginMagnitudeDictionaries(self):
        print "Clearing previous origin and magnitude data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle', 'pazZ', 'pazN',
                       'pazE', 'P', 'PErr1', 'PErr2', 'POnset', 'PPol',
                       'PWeight', 'S', 'SErr1', 'SErr2', 'SOnset', 'SPol',
                       'SWeight',
                       #dont delete the manually picked maxima/minima
                       'MagMin1', 'MagMin1T', 'MagMax1', 'MagMax1T',
                       'MagMin2', 'MagMin2T', 'MagMax2', 'MagMax2T',]
        # we need to delete all station magnitude information from all dicts
        for dict in self.dicts:
            for key in dict.keys():
                if key not in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        self.origin.clear()
        self.magnitude.clear()
        self.event.clear()
        #if 'xmlEventID' in self.dictEvent:
        #    del self.dictEvent['xmlEventID']

    def clearFocmecDictionary(self):
        print "Clearing previous focal mechanism data."
        self.focalMechanism.clear()
        self.focMechList = []
        self.focMechCurrent = None
        self.focMechCount = None

    def drawAllItems(self):
        self.updateAllAxes()

    def updateAllAxes(self):
        st = self.getCurrentStream()
        ids = []
        sta = st[0].stats.station
        xlims = [list(ax.get_xlim()) for ax in self.axs]
        ylims = [list(ax.get_ylim()) for ax in self.axs]
        for _i, ax in enumerate(self.axs):
            # first line is waveform, leave it
            ax.lines = ax.lines[:1]
            # first text is trace id, leave it
            ax.texts = ax.texts[:1]
            ids.append(st[_i].id)
        for pick in self.picks:
            if not pick.time:
                continue
            if pick.waveform_id.station_code != sta:
                continue
            # do drawing in all axes
            for _id, ax in zip(ids, self.axs):
                plot_kwargs = {}
                if pick.waveform_id.getSEEDString() == _id:
                    plot_kwargs['alpha'] = 1
                    self.drawPickLabel(ax, pick)
                else:
                    plot_kwargs['alpha'] = 0.2
                self.drawPick(ax, pick, plot_kwargs=plot_kwargs)
        for arrival in self.origin.arrivals:
            pick = getPickForArrival(self.picks, arrival)
            if not pick or not pick.time:
                continue
            if pick.waveform_id.station_code != sta:
                continue
            for _id, ax in zip(ids, self.axs):
                plot_kwargs = {}
                if pick.waveform_id.getSEEDString() == _id:
                    plot_kwargs['alpha'] = 1
                    self.drawArrivalLabel(ax, arrival, pick)
                else:
                    plot_kwargs['alpha'] = 0.2
                self.drawArrival(ax, arrival, pick, plot_kwargs=plot_kwargs)
        for amplitude in self.amplitudes:
            for _id, ax in zip(ids, self.axs):
                if amplitude.waveform_id.getSEEDString() != _id:
                    continue
                self.drawAmplitude(ax, amplitude)
        for ax, xlims_, ylims_ in zip(self.axs, xlims, ylims):
            ax.set_xlim(xlims_)
            ax.set_ylim(ylims_)

    def drawPick(self, ax, pick, plot_kwargs={}):
        if not pick.time:
            return
        color = PHASE_COLORS[pick.phase_hint]
        reltime = self.time_abs2rel(pick.time)
        ax.axvline(reltime, color=color,
                   linewidth=AXVLINEWIDTH,
                   ymin=0, ymax=1, **plot_kwargs)
        if pick.time_errors.lower_uncertainty or pick.time_errors.upper_uncertainty:
            if pick.time_errors.lower_uncertainty:
                time = reltime - pick.time_errors.lower_uncertainty
                ax.axvline(time, color=color,
                           linewidth=AXVLINEWIDTH,
                           ymin=0.25, ymax=0.75, **plot_kwargs)
            if pick.time_errors.upper_uncertainty:
                time = reltime + pick.time_errors.upper_uncertainty
                ax.axvline(time, color=color,
                           linewidth=AXVLINEWIDTH,
                           ymin=0.25, ymax=0.75, **plot_kwargs)
        elif pick.time_errors.uncertainty:
            time = reltime - pick.time_errors.uncertainty
            ax.axvline(time, color=color,
                       linewidth=AXVLINEWIDTH,
                       ymin=0.25, ymax=0.75, **plot_kwargs)
            time = reltime + pick.time_errors.uncertainty
            ax.axvline(time, color=color,
                       linewidth=AXVLINEWIDTH,
                       ymin=0.25, ymax=0.75, **plot_kwargs)

    def drawArrival(self, ax, arrival, pick, plot_kwargs={}):
        if not pick.time:
            return
        color = "k"
        reltime = self.time_abs2rel(pick.time) - arrival.time_residual
        ax.axvline(reltime, color=color,
                   linewidth=AXVLINEWIDTH,
                   ymin=0, ymax=1, **plot_kwargs)

    def drawAmplitude(self, ax, amplitude, plot_kwargs={}):
        x, y = [], []
        if amplitude.low is not None:
            x.append(self.time_abs2rel(amplitude.low_time))
            y.append(amplitude.low)
        if amplitude.high is not None:
            x.append(self.time_abs2rel(amplitude.high_time))
            y.append(amplitude.high)
        if x:
            ax.plot(x, y, markersize=MAG_MARKER['size'],
                    markeredgewidth=MAG_MARKER['edgewidth'], drawstyle="steps",
                    linewidth=AXVLINEWIDTH, color=PHASE_COLORS['Mag'],
                    marker=MAG_MARKER['marker'], zorder=20)

    def delPick(self, pick):
        if pick in self.picks:
            self.picks.remove(pick)

    def delAmplitude(self, amplitude):
        if amplitude in self.amplitudes:
            self.amplitudes.remove(amplitude)

    def getPick(self, network=None, station=None, phase_hint=None, waveform_id=None, axes=None, setdefault=False, seed_string=None):
        """
        returns first matching pick, does NOT ensure there is only one!
        if setdefault is True then if no pick is found an empty one is returned and inserted into self.picks.
        """
        for p in self.picks:
            if network is not None and network != p.waveform_id.network_code:
                continue
            if station is not None and station != p.waveform_id.station_code:
                continue
            if phase_hint is not None and phase_hint != p.phase_hint:
                continue
            if waveform_id is not None and waveform_id != p.waveform_id:
                continue
            if seed_string is not None and seed_string != p.waveform_id.getSEEDString():
                continue
            if axes is not None:
                _i = self.axs.index(axes)
                _id = self.getCurrentStream()[_i].id
                phase_hint = self.getCurrentPhase()
                if p.waveform_id.getSEEDString() != _id:
                    continue
                if p.phase_hint != phase_hint:
                    continue
            return p
        if setdefault:
            # XXX TODO check if handling of picks/arrivals with regard to
            # resource ids is safe (overwritten picks, arrivals get deleted
            # etc., association of picks/arrivals is ok)
            # also check if setup of resource id strings make sense in general
            # (make versioning of methods possible, etc)
            if seed_string is None:
                raise Exception("Pick setdefault needs seed_string and phase_hint kwargs")
            p = Pick(seed_string=seed_string, phase_hint=phase_hint)
            self.picks.append(p)
            return p
        else:
            return None

    def getAmplitude(self, network=None, station=None, waveform_id=None, axes=None, setdefault=False, seed_string=None):
        """
        returns first matching amplitude, does NOT ensure there is only one!
        if setdefault is True then if no arrival is found an empty one is returned and inserted into self.arrivals.
        """
        for a in self.amplitudes:
            if network is not None and network != a.waveform_id.network_code:
                continue
            if station is not None and station != a.waveform_id.station_code:
                continue
            if waveform_id is not None and waveform_id != a.waveform_id:
                continue
            if seed_string is not None and seed_string != a.waveform_id.getSEEDString():
                continue
            if axes is not None:
                _i = self.axs.index(axes)
                _id = self.getCurrentStream()[_i].id
                if a.waveform_id.getSEEDString() != _id:
                    continue
            return a
        if setdefault:
            # XXX TODO check if handling of picks/arrivals with regard to
            # resource ids is safe (overwritten picks, arrivals get deleted
            # etc., association of picks/arrivals is ok)
            # also check if setup of resource id strings make sense in general
            # (make versioning of methods possible, etc)
            if seed_string is None:
                raise Exception("Arrival setdefault needs seed_string kwarg")
            print seed_string
            a = Amplitude(seed_string=seed_string)
            self.amplitudes.append(a)
            return a
        else:
            return None

    # XXX should be called when getting new event!! XXX
    def removeDuplicatePicks(self):
        """
        Makes sure that any waveform_id/phase_hint combination is unique in
        picks. Leave first occurence, remove all others and warn.
        """
        _ids = [p.waveform_id for p in self.picks]
        _phase_hints = [p.phase_hint for p in self.picks]
        msg = "For picks, any waveform_id / phase_hint combination must " + \
              "be unique. Some non-unique picks were removed!"
        for _id in _ids:
            for _phase_hint in _phase_hints:
                picks = [p for p in self.picks \
                         if p.phase_hint == _phase_hint and \
                         p.waveform_id == _id]
                if len(picks) > 1:
                    warnings.warn(msg)
                    for p in picks[1:]:
                        self.picks.remove(p)

    def setPick(self, pick):
        """
        Replace stored pick with given pick object.
        """
        old = self.getPick(waveform_id=pick.waveform_id, phase_hint=pick.phase_hint)
        self.picks.remove(old)
        self.picks.append(pick)

    def updateAllItems(self):
        #self.delAllItems()
        #self.drawAllItems()
        self.updateAllAxes()

    def getEventFromSeisHub(self, resource_name):
        """
        Fetch a Resource XML from SeisHub
        """
        client = self.clients['SeisHub']
        resource_xml = client.event.getResource(resource_name)

        # parse quakeml
        ev = readEvents(StringIO(resource_xml), format="quakeml")[0]

        try:
            user = ev.creation_info.author
        except:
            user = None

        # parse quakeML event type and select right one or add a custom one
        index = 0
        event_quakeml_type = ev.event_type
        if event_quakeml_type is not None:
            index = self.widgets.qComboBox_eventType.findText(event_quakeml_type.lower(), Qt.MatchExactly)
            if index == -1:
                self.widgets.qComboBox_eventType.addItem(event_quakeml_type)
                index = self.widgets.qComboBox_eventType.findText(event_quakeml_type.lower(), Qt.MatchExactly)
        self.widgets.qComboBox_eventType.setCurrentIndex(index)

        #analyze picks:
        self.picks = ev.picks
        self.removeDuplicatePicks()

        #analyze origin:
        if ev.origins:
            self.origin = ev.origins[0]

        #analyze magnitude:
        if ev.magnitudes:
            self.magnitude = ev.magnitudes[0]
            try:
                self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % \
                        (self.magnitude.mag, self.magnitude.mag_errors)
            except:
                pass

        #analyze stationmagnitudes:
        for stamag in ev.station_magnitudes:
            stamagcontrib = None
            for _c in self.magnitude.station_magnitude_contributions:
                if _c.station_magnitude_id == stamag.resource_id:
                    stamagcontrib = _c
                    break
            # search for streamnumber corresponding to pick
            for i, dict in enumerate(self.dicts):
                if station.strip() != dict['Station']:
                    continue
                else:
                    streamnum = i
                    break
            if streamnum is None:
                err = "Warning: Did not find matching stream for station " + \
                      "magnitude data with id: \"%s\"" % station.strip()
                print >> sys.stderr, err
                continue
            # assign to dictionary
            dict = self.dicts[streamnum]
            dict['station_magnitude'] = stamag
            dict['station_magnitude_contribution'] = stamagcontrib
        
        ## analyze amplitudes (magnitude picks):
        #for ampl in resource_xml.xpath(u".//stationMagnitude/amplitude"):
        #    # attributes
        #    id = ampl.find("waveform").attrib
        #    network = id["networkCode"]
        #    station = id["stationCode"]
        #    location = id["locationCode"]
        #    channel = id['channelCode']
        #    streamnum = None
        #    # search for streamnumber corresponding to pick
        #    for i, dict in enumerate(self.dicts):
        #        if station.strip() != dict['Station']:
        #            continue
        #        else:
        #            streamnum = i
        #            break
        #    if streamnum is None:
        #        err = "Warning: Did not find matching stream for pick " + \
        #              "data with station id: \"%s\"" % station.strip()
        #        print >> sys.stderr, err
        #        continue
        #    dict = self.dicts[streamnum]
        #    st = self.streams[streamnum].copy()
        #    if self.widgets.qToolButton_filter.isChecked():
        #        st = st.copy()
        #        self._filter(st)
        #    # values
        #    tr = st.select(channel=channel)[0]
        #    ind = st.traces.index(tr)
        #    time = ampl.xpath(".//timeWindow/reference")[0].text
        #    time = self.time_abs2rel(UTCDateTime(time))
        #    dict['MagMin%dT' % ind] = time
        #    data_index = int(time * tr.stats.sampling_rate)
        #    data = tr.data[data_index]
        #    dict['MagMin%d' % ind] = data
        #    time += float(ampl.xpath(".//timeWindow/end")[0].text)
        #    dict['MagMax%dT' % ind] = time
        #    data_index = int(time * tr.stats.sampling_rate)
        #    data = tr.data[data_index]
        #    dict['MagMax%d' % ind] = data
        
        #analyze focal mechanism:
        if ev.focal_mechanisms:
            self.focalMechanism = ev.focal_mechanisms[0]
        account = "TODO"  # XXX
        print "Fetched event %i of %i: %s (account: %s, user: %s)"% \
              (self.seishubEventCurrent + 1, self.seishubEventCount,
               resource_name, account, user)

    def updateEventListFromSeisHub(self, starttime, endtime):
        """
        Searches for events in the database and stores a list of resource
        names. All events with at least one pick set in between start- and
        endtime are returned.

        :param starttime: Start datetime as UTCDateTime
        :param endtime: End datetime as UTCDateTime
        """
        self.checkForSysopEventDuplicates(self.T0, self.T1)

        events = self.clients['SeisHub'].event.getList(min_last_pick=starttime,
                                                       max_first_pick=endtime)
        events.sort(key=lambda x: x['resource_name'])
        self.seishubEventList = events
        self.seishubEventCount = len(events)
        # we set the current event-pointer to the last list element, because we
        # iterate the counter immediately when fetching the first event...
        self.seishubEventCurrent = len(events) - 1
        msg = "%i events are available from SeisHub" % len(events)
        for event in events:
            resource_name = event.get('resource_name')
            account = event.get('account')
            try:
                user = ev.creation_info.author
            except:
                user = None
            msg += "\n  - %s (account: %s, user: %s)" % (resource_name,
                                                         account, user)
        print msg

    def checkForSysopEventDuplicates(self, starttime, endtime):
        """
        checks if there is more than one sysop event with picks in between
        starttime and endtime. if that is the case, a warning is issued.
        the user should then resolve this conflict by deleting events until
        only one instance remains.
        at the moment this check is conducted for the current timewindow when
        submitting a sysop event.
        """
        events = self.clients['SeisHub'].event.getList(min_last_pick=starttime,
                                                       max_first_pick=endtime)
        sysop_events = []
        for ev in events:
            try:
                author = ev.creation_info.author
            except:
                continue
            if author == "sysop":
                sysop_events.append(str(event.get('resource_name')))

        # if there is a possible duplicate, pop up a warning window and print a
        # warning in the GUI error textview:
        if len(sysop_events) > 1:
            err = "ObsPyck found more than one sysop event with picks in " + \
                  "the current time window! Please check if these are " + \
                  "duplicate events and delete old resources."
            errlist = "\n".join(sysop_events)
            print >> sys.stderr, err
            print >> sys.stderr, errlist
            qMessageBox = QtGui.QMessageBox()
            qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
            qMessageBox.setIcon(QtGui.QMessageBox.Critical)
            qMessageBox.setWindowTitle("Possible Duplicate SysOp Event!")
            qMessageBox.setText(err)
            qMessageBox.setInformativeText(errlist)
            qMessageBox.setStandardButtons(QtGui.QMessageBox.Ok)
            qMessageBox.exec_()

    def checkForCompleteEvent(self):
        """
        checks if the event has the necessary information a sysop event should
        have::
        
          - datetime (origin time)
          - longitude/latitude/depth
          - magnitude
          - used_p/used_s
        """
        keys_origin = ("time", "latitude", "longitude", "depth")
        # XXX not checking for used-P and used-S-count
        # XXX causes problems for parsing in website?
        keys_magnitude = ("mag",)
        if not self.origin or not all([key in self.origin for key in keys_origin]):
            return False
        if not self.magnitude or not all([key in self.magnitude for key in keys_magnitude]):
            return False
        return True

    def popupBadEventError(self):
        """
        pop up an error window indicating that event information is missing
        """
        keys_origin = ("time", "latitude", "longitude", "depth")
        # XXX not checking for used-P and used-S-count
        # XXX causes problems for parsing in website?
        keys_magnitude = ("mag",)
        missing = [key for key in keys_origin if key not in self.origin]
        missing += [key for key in keys_magnitude if key not in self.magnitude]
        missing = "\n".join(missing)
        err = "The sysop event to submit misses some mandatory information:"
        print >> sys.stderr, err
        print >> sys.stderr, missing
        qMessageBox = QtGui.QMessageBox()
        qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
        qMessageBox.setIcon(QtGui.QMessageBox.Critical)
        qMessageBox.setWindowTitle("SysOp Event with Missing Information!")
        qMessageBox.setText(err)
        qMessageBox.setInformativeText(missing)
        qMessageBox.setStandardButtons(QtGui.QMessageBox.Abort)
        qMessageBox.exec_()


def main():
    """
    Gets executed when the program starts.
    """
    usage = "\n * SeisHub:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 -i BW.R*..EH*,BW.BGLD..EH*\n" + \
            "%prog -t 2010-08-01T12:00:00 -d 30 --seishub-ids BW.R*..EH*,BW.BGLD..EH*\n" + \
            " * ArcLink:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 --arclink-ids GE.APE..BH*,GE.IMMV..BH*\n" + \
            " * combination of clients:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 -i BW.R*..EH* --arclink-ids GE.APE..BH*" + \
            "\n\nGet all available options with: %prog -h"
    parser = optparse.OptionParser(usage)
    for opt_args, opt_kwargs in COMMANDLINE_OPTIONS:
        parser.add_option(*opt_args, **opt_kwargs)
    (options, args) = parser.parse_args()
    # For keybindings option, just print them and exit.
    if options.keybindings:
        for key, value in KEYS.iteritems():
            print "%s: \"%s\"" % (key, value)
        return
    # check for necessary options
    if not any([getattr(parser.values, parser.get_option(opt).dest) \
                for opt in ("--seishub-ids", "--arclink-ids", "-f")]) \
       or not all([getattr(parser.values, parser.get_option(opt).dest) \
                   for opt in ('-d', '-t')]):
        parser.print_usage()
        return
    check_keybinding_conflicts(KEYS)
    # XXX wasn't working as expected
    #if options.debug:
    #    import IPython.Shell
    #    IPython.Shell.IPShellEmbed(['-pdb'],
    #            banner='Entering IPython.  Press Ctrl-D to exit.',
    #            exit_msg='Leaving Interpreter, back to program.')()
    (clients, streams) = fetch_waveforms_with_metadata(options)
    # Create the GUI application
    qApp = QtGui.QApplication(sys.argv)
    obspyck = ObsPyck(clients, streams, options, KEYS)
    qApp.connect(qApp, QtCore.SIGNAL("aboutToQuit()"), obspyck.cleanup)
    os._exit(qApp.exec_())


if __name__ == "__main__":
    main()
